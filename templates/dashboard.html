{% extends 'base.html' %}
{% block title %}Weather Forecasting Dashboard{% endblock %}
{% block head %}
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <link rel="stylesheet" href="/static/dashboard.css">
    
    {# Logger Configuration #}
    <div id="logger-config" 
         data-enabled="{{ config.LOGGING_ENABLED | lower }}"
         data-level="{{ config.LOG_LEVEL }}"
         data-verbose="{{ config.LOG_VERBOSE | lower }}"
         style="display: none;"></div>
    <script>
        // Load logger config from data attributes
        const configElement = document.getElementById('logger-config');
        window.LoggerConfig = {
            enabled: configElement.dataset.enabled === 'true',
            level: configElement.dataset.level,
            verbose: configElement.dataset.verbose === 'true'
        };
    </script>
    
    {# Include Logger Component #}
    {% include 'components/logger.html' with context %}
{% endblock %}
{% block content %}
<div x-data="dashboardApp()" class="min-h-screen bg-gray-50">
    <!-- Loading State -->
    <div x-show="isLoading" class="fixed inset-0 bg-white bg-opacity-90 flex items-center justify-center z-50">
        <div class="text-center">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
            <p class="text-gray-600">Loading Weather Dashboard...</p>
        </div>
    </div>

    <!-- Error State -->
    <div x-show="hasError" class="fixed inset-0 bg-white bg-opacity-90 flex items-center justify-center z-50">
        <div class="text-center max-w-md mx-auto p-6">
            <div class="text-red-500 text-6xl mb-4">‚ö†Ô∏è</div>
            <h2 class="text-xl font-semibold text-gray-900 mb-2">Dashboard Error</h2>
            <p class="text-gray-600 mb-4" x-text="errorMessage"></p>
            <button @click="init()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg">
                Retry
            </button>
        </div>
    </div>

    <!-- Header Section -->
    <div class="bg-white shadow-sm border-b">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center py-6">
                <div class="flex items-center">
                    <div class="text-3xl mr-3">üå¶Ô∏è</div>
                    <div>
                        <h1 class="text-2xl font-bold text-gray-900">Weather Forecasting Dashboard</h1>
                        <p class="text-sm text-gray-500">Real-time monitoring & predictive analytics</p>
                    </div>
                </div>
                <div class="flex items-center space-x-4">
                    <div class="text-sm text-gray-500">
                        Last updated: <span x-text="lastUpdateTime"></span>
                    </div>
                    <button @click="refreshAllData()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg flex items-center space-x-2 transition-colors">
                        <span class="refresh-button">üîÑ</span>
                        <span>Refresh All</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <!-- Real-Time Weather Monitoring -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
            <!-- Current Conditions -->
            <div class="bg-white rounded-xl p-6 card-hover shadow-sm">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-semibold text-gray-900">üå°Ô∏è Current Conditions</h2>
                    <div class="text-sm text-gray-500" x-text="'Updated: ' + lastUpdateTime"></div>
                </div>
                
                <div class="grid grid-cols-3 gap-4">
                    <div class="text-center">
                        <div class="text-3xl font-bold text-red-600" x-text="currentWeather.temperature ? currentWeather.temperature.toFixed(1) + '¬∞C' : '--'"></div>
                        <div class="text-sm text-gray-600">Temperature</div>
                    </div>
                    <div class="text-center">
                        <div class="text-3xl font-bold text-blue-600" x-text="currentWeather.humidity ? currentWeather.humidity.toFixed(1) + '%' : '--'"></div>
                        <div class="text-sm text-gray-600">Humidity</div>
                    </div>
                    <div class="text-center">
                        <div class="text-3xl font-bold text-green-600" x-text="currentWeather.pressure ? currentWeather.pressure.toFixed(1) + 'hPa' : '--'"></div>
                        <div class="text-sm text-gray-600">Pressure</div>
                    </div>
                </div>
                
                <!-- Last Predicted Temperature -->
                <div class="mt-4 p-3 bg-gradient-to-r from-purple-50 to-blue-50 rounded-lg border border-purple-200">
                    <div class="text-center">
                        <div class="text-2xl font-bold text-purple-700" x-text="lastPredictedTemp ? lastPredictedTemp.toFixed(1) + '¬∞C' : '--'"></div>
                        <div class="text-sm text-purple-600">Last Predicted Temperature</div>
                        <div class="text-xs text-purple-500 mt-1" x-text="lastPredictedTempTime ? 'Predicted at: ' + formatDateTime(lastPredictedTempTime) : ''"></div>
                    </div>
                </div>
                
                <div class="mt-4 p-3 bg-gray-50 rounded-lg">
                    <div class="text-sm text-gray-600">
                        <strong>Module:</strong> <span x-text="currentWeather.module || 'Unknown'"></span>
                    </div>
                    <div class="text-sm text-gray-600">
                        <strong>Timestamp:</strong> <span x-text="currentWeather.timestamp || '--'"></span>
                    </div>
                </div>
            </div>

            <!-- Model Performance -->
            <div class="bg-white rounded-xl p-6 card-hover shadow-sm">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-semibold text-gray-900">üìà Model Performance</h2>
                    <button @click="refreshBenchmark()" class="text-blue-600 hover:text-blue-800 text-sm">üîÑ Refresh</button>
                </div>
                
                <div class="grid grid-cols-3 gap-4">
                    <div class="text-center">
                        <div class="text-2xl font-bold text-blue-700" x-text="modelMetrics.mae ? modelMetrics.mae.toFixed(3) : '--'"></div>
                        <div class="text-sm text-gray-600">MAE</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-blue-700" x-text="modelMetrics.rmse ? modelMetrics.rmse.toFixed(3) : '--'"></div>
                        <div class="text-sm text-gray-600">RMSE</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-blue-700" x-text="modelMetrics.r2 ? modelMetrics.r2.toFixed(3) : '--'"></div>
                        <div class="text-sm text-gray-600">R¬≤</div>
                    </div>
                </div>
                
                <div x-show="modelMetrics.error" class="mt-4 p-3 bg-red-50 border border-red-200 rounded-lg">
                    <div class="text-sm text-red-600" x-text="modelMetrics.error"></div>
                </div>
            </div>
        </div>

        <!-- Controls Section -->
        <div class="bg-white rounded-xl p-6 mb-8 shadow-sm">
            <h2 class="text-lg font-semibold text-gray-900 mb-4">üìã Controls & Filters</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Time Range</label>
                    <select x-model="controls.timeRange" @change="updateData()" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <template x-for="option in timeRangeOptions" :key="option.value">
                            <option :value="option.value" x-text="option.label"></option>
                        </template>
                    </select>
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Sensor Module</label>
                    <select x-model="controls.selectedModule" @change="updateData()" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="">All Modules</option>
                        <template x-for="module in availableModules" :key="module">
                            <option :value="module" x-text="module"></option>
                        </template>
                    </select>
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Data Type</label>
                    <select x-model="controls.dataType" @change="updateData()" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="preprocessed">Preprocessed</option>
                        <option value="source">Raw Source</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Predictive Analytics Dashboard -->
        <div class="bg-white rounded-xl p-6 mb-8 card-hover shadow-sm">
            <div class="flex items-center justify-between mb-6">
                <h2 class="text-xl font-semibold text-gray-900">üîÆ Predictive Analytics</h2>
                <div class="flex items-center space-x-4">
                    <div class="text-sm text-gray-500">
                        Auto-refresh: <span x-text="autoRefreshEnabled ? 'ON' : 'OFF'"></span>
                    </div>
                    <button @click="toggleAutoRefresh()" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm">
                        <span x-text="autoRefreshEnabled ? 'Disable' : 'Enable'"></span>
                    </button>
                </div>
            </div>
            
            <div class="chart-container">
                <div id="predictionsChart"></div>
                <div x-show="chartsDisabled" class="text-center py-8 text-gray-500">
                    <div class="text-2xl mb-2">üìä</div>
                    <p>Predictions chart temporarily disabled</p>
                    <p class="text-sm">Data is still being collected and displayed in the table below</p>
                </div>
            </div>
            
            <!-- Recent Predictions Table -->
            <div class="mt-6">
                <h3 class="text-lg font-semibold text-gray-900 mb-3">Recent Predictions</h3>
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Timestamp</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Predicted Temp</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Confidence</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
                            <template x-for="prediction in recentPredictions.slice(0, 5)" :key="prediction.timestamp">
                                <tr>
                                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900" x-text="formatDateTime(prediction.timestamp)"></td>
                                    <td class="px-6 py-4 whitespace-nowrap text-sm font-semibold text-gray-900" x-text="prediction.predicted_temperature.toFixed(1) + '¬∞C'"></td>
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <span class="prediction-confidence" :class="getConfidenceClass(prediction.confidence)" x-text="(prediction.confidence * 100).toFixed(1) + '%'"></span>
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <span class="status-dot status-green"></span>
                                        <span class="text-sm text-gray-900">Active</span>
                                    </td>
                                </tr>
                            </template>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Advanced Data Analysis Suite -->
        <div class="bg-white rounded-xl p-6 mb-8 card-hover shadow-sm">
            <div class="flex items-center justify-between mb-6">
                <h2 class="text-xl font-semibold text-gray-900">üìä Advanced Data Analysis</h2>
                <button @click="refreshAnalysis()" class="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg card-hover">
                    üîÑ Refresh Analysis
                </button>
            </div>
            
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <template x-for="plot in analysisPlots" :key="plot.id">
                    <div>
                        <h3 class="text-lg font-semibold text-gray-700 mb-3" x-text="plot.title"></h3>
                        <div class="relative">
                            <img :id="plot.id" :src="plot.src" :alt="plot.title" class="w-full rounded-lg shadow-sm">
                            <div x-show="analysisLoading[plot.key]" class="absolute inset-0 bg-gray-200 loading-skeleton rounded-lg"></div>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- Historical Data Visualization -->
        <div class="bg-white rounded-xl p-6 mb-8 card-hover shadow-sm">
            <h2 class="text-xl font-semibold text-gray-900 mb-6">üìà Historical Data Visualization</h2>
            
            <!-- Historical Data Controls -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Historical Time Range</label>
                    <select x-model="historicalControls.timeRange" @change="updateHistoricalData()" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <template x-for="option in timeRangeOptions" :key="option.value">
                            <option :value="option.value" x-text="option.label"></option>
                        </template>
                    </select>
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Historical Module</label>
                    <select x-model="historicalControls.selectedModule" @change="updateHistoricalData()" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="">All Modules</option>
                        <template x-for="module in availableModules" :key="module">
                            <option :value="module" x-text="module"></option>
                        </template>
                    </select>
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Historical Data Type</label>
                    <select x-model="historicalControls.dataType" @change="updateHistoricalData()" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="preprocessed">Preprocessed</option>
                        <option value="source">Raw Source</option>
                    </select>
                </div>
                
                <div class="flex items-end">
                    <button @click="refreshHistoricalData()" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition-colors">
                        üîÑ Refresh Historical
                    </button>
                </div>
            </div>
            
            <!-- Individual Historical Charts -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <template x-for="chart in historicalCharts" :key="chart.id">
                    <div class="bg-gray-50 rounded-lg p-4">
                        <h3 class="text-lg font-semibold text-gray-900 mb-3" x-text="chart.title"></h3>
                        <div class="chart-container" style="height: 300px;">
                            <div :id="chart.id"></div>
                            <div x-show="chartsDisabled" class="text-center py-8 text-gray-500">
                                <div class="text-2xl mb-2" x-text="chart.icon"></div>
                                <p x-text="chart.name + ' chart temporarily disabled'"></p>
                            </div>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- System Status Overview -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
            <template x-for="status in systemStatusItems" :key="status.key">
                <div class="bg-white rounded-xl p-6 card-hover shadow-sm">
                    <div class="flex items-center justify-between">
                        <div>
                            <p class="text-sm font-medium text-gray-600" x-text="status.label"></p>
                            <div class="flex items-center mt-2" x-show="status.type === 'status'">
                                <span class="status-dot" :class="getStatusClass(systemStatus[status.key])"></span>
                                <span class="text-sm font-semibold" x-text="systemStatus[status.key] ? status.trueText : status.falseText"></span>
                            </div>
                            <div class="mt-2" x-show="status.type === 'count'">
                                <span class="text-lg font-bold text-gray-900" x-text="systemStatus[status.key] || 0"></span>
                            </div>
                        </div>
                        <div class="text-2xl" x-text="status.icon"></div>
                    </div>
                </div>
            </template>
        </div>
    </div>
</div>

<script>
function dashboardApp() {
    return {
        // State
        lastUpdateTime: '--',
        autoRefreshEnabled: false,
        autoRefreshInterval: null,
        isLoading: true,
        hasError: false,
        errorMessage: '',
        chartsDisabled: false, // New flag to disable charts if they cause issues
        
        // Data
        currentWeather: {},
        systemStatus: {
            sourceDb: false,
            scheduler: false,
            model: false,
            records: 0
        },
        modelMetrics: {
            mae: null,
            rmse: null,
            r2: null,
            error: null
        },
        recentPredictions: [],
        availableModules: [],
        sensorData: [],
        lastPredictedTemp: null,
        lastPredictedTempTime: null,
        
        // Controls
        controls: {
            timeRange: '168',
            selectedModule: '',
            dataType: 'preprocessed'
        },
        
        // Historical Data Controls
        historicalControls: {
            timeRange: '168',
            selectedModule: '',
            dataType: 'preprocessed'
        },
        
        // Loading states
        analysisLoading: {
            timeSeries: false,
            distributions: false,
            correlation: false,
            temporal: false
        },
        
        // Charts
        predictionsChart: null,
        temperatureChart: null,
        humidityChart: null,
        pressureChart: null,
        
        // Data structures for templates
        timeRangeOptions: [
            { value: '6', label: 'Last 6 hours' },
            { value: '12', label: 'Last 12 hours' },
            { value: '24', label: 'Last 24 hours' },
            { value: '48', label: 'Last 48 hours' },
            { value: '168', label: 'Last week' },
            { value: '720', label: 'Last month' }
        ],
        
        systemStatusItems: [
            { key: 'sourceDb', label: 'Database Status', type: 'status', trueText: 'Healthy', falseText: 'Error', icon: 'üóÑÔ∏è' },
            { key: 'scheduler', label: 'Scheduler Status', type: 'status', trueText: 'Running', falseText: 'Stopped', icon: '‚è∞' },
            { key: 'model', label: 'Model Status', type: 'status', trueText: 'Trained', falseText: 'Not Ready', icon: 'ü§ñ' },
            { key: 'records', label: 'Data Records', type: 'count', icon: 'üìä' }
        ],
        
        historicalCharts: [
            { id: 'temperatureChart', name: 'Temperature', title: 'üå°Ô∏è Temperature', icon: 'üå°Ô∏è', field: 'temperature', color: 'rgb(239, 68, 68)', unit: '¬∞C' },
            { id: 'humidityChart', name: 'Humidity', title: 'üíß Humidity', icon: 'üíß', field: 'humidity', color: 'rgb(59, 130, 246)', unit: '%' },
            { id: 'pressureChart', name: 'Pressure', title: 'üå™Ô∏è Pressure', icon: 'üå™Ô∏è', field: 'pressure', color: 'rgb(34, 197, 94)', unit: 'hPa' }
        ],
        
        analysisPlots: [
            { id: 'time-series-plot', key: 'timeSeries', title: 'Time Series Analysis', src: '/api/analysis/time-series' },
            { id: 'distribution-plot', key: 'distributions', title: 'Data Distributions', src: '/api/analysis/distributions' },
            { id: 'correlation-plot', key: 'correlation', title: 'Correlation Matrix', src: '/api/analysis/correlation' },
            { id: 'temporal-plot', key: 'temporal', title: 'Temporal Patterns', src: '/api/analysis/temporal' }
        ],
        
        // Methods
        async init() {
            try {
                this.isLoading = true;
                this.hasError = false;
                this.errorMessage = '';
                
                window.logger.logInit();
                
                // Wait for Plotly to be available
                let retries = 0;
                while (typeof Plotly === 'undefined' && retries < 10) {
                    window.logger.debug('Waiting for Plotly to load...', { retry: retries });
                    await new Promise(resolve => setTimeout(resolve, 500));
                    retries++;
                }
                
                if (typeof Plotly === 'undefined') {
                    window.logger.error('Plotly failed to load after retries');
                    this.chartsDisabled = true;
                } else {
                    window.logger.info('Plotly loaded successfully');
                }
                
                // Wait for DOM to be ready
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Check if chart containers exist
                const containers = ['predictionsChart', 'temperatureChart', 'humidityChart', 'pressureChart'];
                const containerStatus = {};
                containers.forEach(id => containerStatus[id] = !!document.getElementById(id));
                
                window.logger.logData(containerStatus, 'Chart containers found');
                
                // Set up charts first
                this.setupCharts();
                
                // Wait a bit for charts to be ready
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Then load data
                await this.loadInitialData();
                
                this.startAutoRefresh();
                this.isLoading = false;
                window.logger.info('Dashboard initialization completed');
            } catch (error) {
                window.logger.logError(error, 'Dashboard initialization failed');
                this.isLoading = false;
                this.hasError = true;
                this.errorMessage = 'Failed to initialize dashboard. Please refresh the page.';
            }
        },
        
        async loadInitialData() {
            await Promise.all([
                this.loadSystemStatus(),
                this.loadCurrentWeather(),
                this.loadModelMetrics(),
                this.loadPredictions(),
                this.loadSensorData(),
                this.loadModules()
            ]);
            this.updateLastUpdateTime();
        },
        
        async loadSystemStatus() {
            try {
                const response = await fetch('/api/stats');
                const data = await response.json();
                
                // Check if source database is working
                // Consider it healthy if status is 'online' OR if we have sensor records (indicating successful connection)
                const sourceDbHealthy = data.raw_data?.status === 'online' || 
                                       (data.raw_data?.sensor_records !== undefined && data.raw_data?.sensor_records >= 0);
                
                this.systemStatus = {
                    sourceDb: sourceDbHealthy,
                    scheduler: data.is_running === true,
                    model: data.model_trained === true,
                    records: data.preprocessed_records || 0
                };
            } catch (error) {
                window.logger.logError(error, 'Error loading system status');
                // If we can't even fetch stats, assume database is down
                this.systemStatus = {
                    sourceDb: false,
                    scheduler: false,
                    model: false,
                    records: 0
                };
            }
        },
        
        async loadCurrentWeather() {
            try {
                // Try preprocessed data first
                let response = await fetch('/api/preprocessed-data?hours_back=1&limit=1');
                let data = await response.json();
                
                if (data.length > 0) {
                    this.currentWeather = {
                        temperature: data[0].temperature,
                        humidity: data[0].humidity,
                        pressure: data[0].pressure,
                        module: 'preprocessed', // Preprocessed data doesn't have module info
                        timestamp: new Date(data[0].timestamp).toLocaleString()
                    };
                } else {
                    // Fallback to source data
                    response = await fetch('/api/sensor-data?hours=1&limit=1');
                    data = await response.json();
                    if (data.length > 0) {
                        this.currentWeather = {
                            temperature: data[0].temperature,
                            humidity: data[0].humidity,
                            pressure: data[0].pressure,
                            module: data[0].module,
                            timestamp: new Date(data[0].timestamp).toLocaleString()
                        };
                    }
                }
            } catch (error) {
                window.logger.logError(error, 'Error loading current weather');
            }
        },
        
        async loadModelMetrics() {
            try {
                const response = await fetch('/api/model/benchmark');
                if (response.ok) {
                    const data = await response.json();
                    this.modelMetrics = {
                        mae: data.mae,
                        rmse: data.rmse,
                        r2: data.r2,
                        error: null
                    };
                } else {
                    const errorData = await response.json();
                    this.modelMetrics.error = errorData.error || 'No benchmark data available';
                }
            } catch (error) {
                this.modelMetrics.error = 'Error loading benchmark data';
            }
        },
        
        async loadPredictions() {
            try {
                // Use the time range for predictions as well, not just forecast hours
                const response = await fetch(`/api/predictions?hours=${this.controls.timeRange}`);
                if (!response.ok) {
                    console.warn('Failed to load predictions:', response.status);
                    this.recentPredictions = [];
                    return;
                }
                const data = await response.json();
                window.logger.logData(data.length, 'Predictions loaded');
                
                // Sort data by timestamp to ensure chronological order
                const sortedData = Array.isArray(data) ? data.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)) : [];
                
                if (sortedData.length > 0) {
                    window.logger.debug('Prediction time range:', new Date(sortedData[0].timestamp), 'to', new Date(sortedData[sortedData.length - 1].timestamp));
                }
                this.recentPredictions = sortedData;
                
                // Set last predicted temperature and time
                if (this.recentPredictions.length > 0) {
                    this.lastPredictedTemp = this.recentPredictions[0].predicted_temperature;
                    this.lastPredictedTempTime = this.recentPredictions[0].timestamp;
                } else {
                    this.lastPredictedTemp = null;
                    this.lastPredictedTempTime = null;
                }
                
                // Only update chart if we have data and chart is ready and not disabled
                if (this.recentPredictions.length > 0 && this.predictionsChart && !this.chartsDisabled) {
                    this.updatePredictionsChart();
                }
            } catch (error) {
                window.logger.logError(error, 'Error loading predictions');
                this.recentPredictions = [];
            }
        },
        
        async loadSensorData() {
            try {
                window.logger.debug('Loading sensor data with controls:', this.historicalControls);
                
                const moduleParam = this.historicalControls.selectedModule ? `&module_id=${this.historicalControls.selectedModule}` : '';
                
                let response;
                let url;
                if (this.historicalControls.dataType === 'preprocessed') {
                    // Use preprocessed data endpoint
                    url = `/api/preprocessed-data?hours_back=${this.historicalControls.timeRange}${moduleParam}`;
                    response = await fetch(url);
                } else {
                    // Use source data endpoint
                    url = `/api/sensor-data?hours=${this.historicalControls.timeRange}${moduleParam}`;
                    response = await fetch(url);
                }
                
                window.logger.debug('Fetching sensor data from:', url);
                
                if (!response.ok) {
                    console.warn('Failed to load sensor data:', response.status);
                    this.sensorData = [];
                    return;
                }
                const data = await response.json();
                window.logger.logData(data.length, 'Sensor data loaded');
                
                // Sort data by timestamp to ensure chronological order
                const sortedData = Array.isArray(data) ? data.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)) : [];
                
                if (sortedData.length > 0) {
                    window.logger.debug('Time range:', new Date(sortedData[0].timestamp), 'to', new Date(sortedData[sortedData.length - 1].timestamp));
                }
                this.sensorData = sortedData;
                
                // Update individual charts if they're ready and not disabled
                if (this.sensorData.length > 0 && !this.chartsDisabled) {
                    window.logger.debug('Updating individual charts with', this.sensorData.length, 'data points');
                    if (this.temperatureChart) {
                        try {
                            this.updateTemperatureChart();
                        } catch (error) {
                            console.error('Failed to update temperature chart:', error);
                        }
                    }
                    if (this.humidityChart) {
                        try {
                            this.updateHumidityChart();
                        } catch (error) {
                            console.error('Failed to update humidity chart:', error);
                        }
                    }
                    if (this.pressureChart) {
                        try {
                            this.updatePressureChart();
                        } catch (error) {
                            console.error('Failed to update pressure chart:', error);
                        }
                    }
                } else {
                    window.logger.debug('Charts not updated - data length:', this.sensorData.length, 'charts disabled:', this.chartsDisabled);
                }
            } catch (error) {
                window.logger.logError(error, 'Error loading sensor data');
                this.sensorData = [];
            }
        },
        
        async loadModules() {
            try {
                const response = await fetch('/api/modules');
                const data = await response.json();
                this.availableModules = data.modules || [];
            } catch (error) {
                window.logger.logError(error, 'Error loading modules');
            }
        },
        
        setupCharts() {
            window.logger.info('Setting up charts...');
            
            // Check if charts are disabled
            if (this.chartsDisabled) {
                window.logger.info('Charts are disabled, skipping initialization');
                return;
            }
            
            // Check if Plotly is available
            if (typeof Plotly === 'undefined') {
                window.logger.error('Plotly is not loaded');
                this.chartsDisabled = true;
                return;
            }
            
            window.logger.info('Plotly is available, proceeding with chart setup');
            
            // Predictions Chart
            const predictionsCtx = document.getElementById('predictionsChart');
            if (!predictionsCtx) {
                console.error('Predictions chart canvas not found');
                this.chartsDisabled = true;
                return;
            }
            
            window.logger.debug('Predictions chart container found:', predictionsCtx);
            
            try {
                // Create initial empty chart with proper Plotly structure
                const predictionsData = [
                    {
                        x: [],
                        y: [],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Historical Temperature',
                        line: {
                            color: 'rgb(59, 130, 246)',
                            width: 2
                        },
                        marker: {
                            size: 4,
                            color: 'rgb(59, 130, 246)'
                        },
                        hovertemplate: '%{x}<br>Temperature: %{y:.1f}¬∞C<extra></extra>'
                    },
                    {
                        x: [],
                        y: [],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Predicted Temperature',
                        line: {
                            color: 'rgb(239, 68, 68)',
                            width: 2
                        },
                        marker: {
                            size: 4,
                            color: 'rgb(239, 68, 68)'
                        },
                        hovertemplate: '%{x}<br>Predicted: %{y:.1f}¬∞C<extra></extra>'
                    }
                ];
                
                const predictionsLayout = {
                    title: {
                        text: 'Temperature Predictions vs Historical Data',
                        font: { size: 16 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 12 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Temperature (¬∞C)',
                            font: { size: 12 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    legend: {
                        orientation: 'h',
                        y: 1.1,
                        x: 0.5,
                        xanchor: 'center',
                        bgcolor: 'rgba(255,255,255,0.8)'
                    },
                    height: 400,
                    margin: { t: 60, b: 60, l: 60, r: 40 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                const config = {
                    responsive: true,
                    displayModeBar: true,
                    modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                    displaylogo: false
                };
                
                window.logger.debug('Creating predictions chart with data:', predictionsData);
                window.logger.debug('Layout:', predictionsLayout);
                
                Plotly.newPlot(predictionsCtx, predictionsData, predictionsLayout, config);
                this.predictionsChart = predictionsCtx;
                window.logger.info('Predictions chart initialized successfully');
                

            } catch (error) {
                console.error('Error creating predictions chart:', error);
                this.predictionsChart = null;
                this.chartsDisabled = true;
                this.disablePredictionsChart();
            }
            
            // Temperature Chart
            const temperatureCtx = document.getElementById('temperatureChart');
            if (!temperatureCtx) {
                console.error('Temperature chart canvas not found');
                return;
            }
            
            console.log('Temperature chart container found:', temperatureCtx);
            
            try {
                const temperatureData = [
                    {
                        x: [],
                        y: [],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Temperature',
                        line: {
                            color: 'rgb(239, 68, 68)',
                            width: 2
                        },
                        marker: {
                            size: 3,
                            color: 'rgb(239, 68, 68)'
                        },
                        hovertemplate: '%{x}<br>Temperature: %{y:.1f}¬∞C<extra></extra>'
                    }
                ];
                
                const temperatureLayout = {
                    title: {
                        text: 'Temperature Over Time',
                        font: { size: 14 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 10 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Temperature (¬∞C)',
                            font: { size: 10 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    height: 300,
                    margin: { t: 40, b: 40, l: 50, r: 20 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                console.log('Creating temperature chart with data:', temperatureData);
                console.log('Temperature layout:', temperatureLayout);
                
                Plotly.newPlot(temperatureCtx, temperatureData, temperatureLayout, config);
                this.temperatureChart = temperatureCtx;
                console.log('Temperature chart initialized successfully');
                
                // Test if the chart is actually rendered
                setTimeout(() => {
                    const chartElement = temperatureCtx.querySelector('.plotly');
                    if (chartElement) {
                        console.log('Temperature chart element found and rendered:', chartElement);
                    } else {
                        console.warn('Temperature chart element not found after initialization');
                    }
                }, 1000);
            } catch (error) {
                console.error('Error creating temperature chart:', error);
                this.temperatureChart = null;
            }
            
            // Humidity Chart
            const humidityCtx = document.getElementById('humidityChart');
            if (!humidityCtx) {
                console.error('Humidity chart canvas not found');
                return;
            }
            
            console.log('Humidity chart container found:', humidityCtx);
            
            try {
                const humidityData = [
                    {
                        x: [],
                        y: [],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Humidity',
                        line: {
                            color: 'rgb(59, 130, 246)',
                            width: 2
                        },
                        marker: {
                            size: 3,
                            color: 'rgb(59, 130, 246)'
                        },
                        hovertemplate: '%{x}<br>Humidity: %{y:.1f}%<extra></extra>'
                    }
                ];
                
                const humidityLayout = {
                    title: {
                        text: 'Humidity Over Time',
                        font: { size: 14 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 10 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Humidity (%)',
                            font: { size: 10 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    height: 300,
                    margin: { t: 40, b: 40, l: 50, r: 20 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                Plotly.newPlot(humidityCtx, humidityData, humidityLayout, config);
                this.humidityChart = humidityCtx;
                console.log('Humidity chart initialized successfully');
            } catch (error) {
                console.error('Error creating humidity chart:', error);
                this.humidityChart = null;
            }
            
            // Pressure Chart
            const pressureCtx = document.getElementById('pressureChart');
            if (!pressureCtx) {
                console.error('Pressure chart canvas not found');
                return;
            }
            
            console.log('Pressure chart container found:', pressureCtx);
            
            try {
                const pressureData = [
                    {
                        x: [],
                        y: [],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Pressure',
                        line: {
                            color: 'rgb(34, 197, 94)',
                            width: 2
                        },
                        marker: {
                            size: 3,
                            color: 'rgb(34, 197, 94)'
                        },
                        hovertemplate: '%{x}<br>Pressure: %{y:.1f}hPa<extra></extra>'
                    }
                ];
                
                const pressureLayout = {
                    title: {
                        text: 'Pressure Over Time',
                        font: { size: 14 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 10 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Pressure (hPa)',
                            font: { size: 10 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    height: 300,
                    margin: { t: 40, b: 40, l: 50, r: 20 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                Plotly.newPlot(pressureCtx, pressureData, pressureLayout, config);
                this.pressureChart = pressureCtx;
                console.log('Pressure chart initialized successfully');
            } catch (error) {
                console.error('Error creating pressure chart:', error);
                this.pressureChart = null;
            }
        },
        
        updatePredictionsChart() {
            if (this.chartsDisabled || !this.predictionsChart) {
                console.warn('Predictions chart not available or disabled');
                return;
            }
            
            try {
                // Use all available data instead of limiting to 50 points
                const historicalData = this.sensorData && this.sensorData.length > 0 ? this.sensorData : [];
                const predictionData = this.recentPredictions && this.recentPredictions.length > 0 ? this.recentPredictions : [];
                
                console.log('Historical data for chart:', historicalData.length, 'points');
                console.log('Prediction data for chart:', predictionData.length, 'points');
                console.log('Sample historical data:', historicalData.slice(0, 3));
                console.log('Sample prediction data:', predictionData.slice(0, 3));
                
                // Create data arrays for Plotly with proper timestamp handling
                const historicalX = historicalData.map(d => new Date(d.timestamp));
                const historicalY = historicalData.map(d => Number(d.temperature) || 0);
                
                const predictionX = predictionData.map(d => new Date(d.timestamp));
                const predictionY = predictionData.map(d => Number(d.predicted_temperature) || 0);
                
                console.log('Historical X range:', historicalX.length > 0 ? `${historicalX[0]} to ${historicalX[historicalX.length-1]}` : 'empty');
                console.log('Prediction X range:', predictionX.length > 0 ? `${predictionX[0]} to ${predictionX[predictionX.length-1]}` : 'empty');
                
                // If we have no data at all, don't update the chart
                if (historicalX.length === 0 && predictionX.length === 0) {
                    console.warn('No data available for predictions chart');
                    return;
                }
                
                // Always use replot for better timestamp handling and to ensure proper updates
                this.replotPredictionsChart(historicalX, historicalY, predictionX, predictionY);
                
            } catch (error) {
                console.error('Error updating predictions chart:', error);
                // Disable the chart if it keeps failing
                this.disablePredictionsChart();
            }
        },
        
        replotPredictionsChart(historicalX, historicalY, predictionX, predictionY) {
            try {
                const plotData = [
                    {
                        x: historicalX,
                        y: historicalY,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Historical Temperature',
                        line: {
                            color: 'rgb(59, 130, 246)',
                            width: 2
                        },
                        marker: {
                            size: 4,
                            color: 'rgb(59, 130, 246)'
                        },
                        hovertemplate: '%{x}<br>Temperature: %{y:.1f}¬∞C<extra></extra>'
                    },
                    {
                        x: predictionX,
                        y: predictionY,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Predicted Temperature',
                        line: {
                            color: 'rgb(239, 68, 68)',
                            width: 2
                        },
                        marker: {
                            size: 4,
                            color: 'rgb(239, 68, 68)'
                        },
                        hovertemplate: '%{x}<br>Predicted: %{y:.1f}¬∞C<extra></extra>'
                    }
                ];
                
                const layout = {
                    title: {
                        text: 'Temperature Predictions vs Historical Data',
                        font: { size: 16 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 12 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Temperature (¬∞C)',
                            font: { size: 12 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    legend: {
                        orientation: 'h',
                        y: 1.1,
                        x: 0.5,
                        xanchor: 'center',
                        bgcolor: 'rgba(255,255,255,0.8)'
                    },
                    height: 400,
                    margin: { t: 60, b: 60, l: 60, r: 40 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                const config = {
                    responsive: true,
                    displayModeBar: true,
                    modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                    displaylogo: false
                };
                
                Plotly.newPlot(this.predictionsChart, plotData, layout, config);
                console.log('Predictions chart replotted successfully');
            } catch (error) {
                console.error('Error replotting predictions chart:', error);
                this.disablePredictionsChart();
            }
        },
        
        updateChart(chartType) {
            const chart = this.historicalCharts.find(c => c.name.toLowerCase() === chartType.toLowerCase());
            if (!chart) {
                window.logger.warn(`Chart type ${chartType} not found`);
                return;
            }
            
            const chartElement = this[chart.id.replace('Chart', 'Chart')];
            if (this.chartsDisabled || !chartElement) {
                window.logger.warn(`${chartType} chart not available or disabled`);
                return;
            }
            
            try {
                if (!this.sensorData || this.sensorData.length === 0) {
                    window.logger.warn(`No sensor data available for ${chartType} chart`);
                    return;
                }
                
                window.logger.logData(this.sensorData.length, `${chartType} chart data points`);
                
                // Create data arrays for Plotly with proper timestamp handling
                const x = this.sensorData.map(d => new Date(d.timestamp));
                const values = this.sensorData.map(d => Number(d[chart.field]) || 0);
                
                // Replot the chart
                this.replotChart(chart, x, values);
                
            } catch (error) {
                window.logger.logError(error, `${chartType} chart update failed`);
                this.disableChart(chart.id);
            }
        },
        
        updateTemperatureChart() {
            this.updateChart('Temperature');
        },
        
        replotChart(chart, x, values) {
            try {
                window.logger.debug(`Replotting ${chart.name} chart with ${x.length} data points`);
                
                const plotData = [
                    {
                        x: x,
                        y: values,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: chart.name,
                        line: {
                            color: chart.color,
                            width: 2
                        },
                        marker: {
                            size: 3,
                            color: chart.color
                        },
                        hovertemplate: `%{x}<br>${chart.name}: %{y:.1f}${chart.unit}<extra></extra>`
                    }
                ];
                
                const layout = {
                    title: {
                        text: `${chart.name} Over Time`,
                        font: { size: 14 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 10 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: `${chart.name} (${chart.unit})`,
                            font: { size: 10 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    height: 300,
                    margin: { t: 40, b: 40, l: 50, r: 20 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                const config = {
                    responsive: true,
                    displayModeBar: true,
                    modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                    displaylogo: false
                };
                
                const chartElement = this[chart.id.replace('Chart', 'Chart')];
                Plotly.newPlot(chartElement, plotData, layout, config);
                window.logger.info(`${chart.name} chart replotted successfully`);
                
            } catch (error) {
                window.logger.logError(error, `${chart.name} chart replot failed`);
                this.disableChart(chart.id);
            }
        },
        

        
        updateHumidityChart() {
            this.updateChart('Humidity');
        },
        

        
        updatePressureChart() {
            this.updateChart('Pressure');
        },
        

        
        disablePredictionsChart() {
            window.logger.warn('Disabling predictions chart due to errors');
            if (this.predictionsChart) {
                try {
                    Plotly.purge(this.predictionsChart);
                } catch (e) {
                    window.logger.logError(e, 'Error purging predictions chart');
                }
                this.predictionsChart = null;
            }
            // Hide the chart container
            const container = document.querySelector('.chart-container');
            if (container) {
                container.innerHTML = '<div class="text-center py-8 text-gray-500">Predictions chart temporarily disabled due to data issues</div>';
            }
        },
        
        disableChart(chartId) {
            const chart = this.historicalCharts.find(c => c.id === chartId);
            if (chart) {
                window.logger.warn(`Disabling ${chart.name} chart due to errors`);
                const chartElement = this[chartId.replace('Chart', 'Chart')];
                if (chartElement) {
                    try {
                        Plotly.purge(chartElement);
                    } catch (e) {
                        window.logger.logError(e, `Error purging ${chart.name} chart`);
                    }
                    this[chartId.replace('Chart', 'Chart')] = null;
                }
            }
        },
        

        
        async updateData() {
            await this.loadSensorData();
            await this.loadPredictions(); // Also load predictions for the time range
            await this.loadCurrentWeather();
            
            // Update individual charts if they're ready and not disabled
            if (this.sensorData.length > 0 && !this.chartsDisabled) {
                if (this.temperatureChart) {
                    try {
                        this.updateTemperatureChart();
                    } catch (error) {
                        console.error('Failed to update temperature chart:', error);
                    }
                }
                if (this.humidityChart) {
                    try {
                        this.updateHumidityChart();
                    } catch (error) {
                        console.error('Failed to update humidity chart:', error);
                    }
                }
                if (this.pressureChart) {
                    try {
                        this.updatePressureChart();
                    } catch (error) {
                        console.error('Failed to update pressure chart:', error);
                    }
                }
            }
            
            // Update predictions chart if ready and not disabled
            if (this.predictionsChart && this.recentPredictions.length > 0 && !this.chartsDisabled) {
                try {
                    this.updatePredictionsChart();
                } catch (error) {
                    console.error('Failed to update predictions chart:', error);
                }
            }
        },
        
        async updateHistoricalData() {
            await this.loadSensorData();
            if (this.temperatureChart && this.sensorData.length > 0 && !this.chartsDisabled) {
                try {
                    this.updateTemperatureChart();
                } catch (error) {
                    console.error('Failed to update temperature chart:', error);
                }
            }
            if (this.humidityChart && this.sensorData.length > 0 && !this.chartsDisabled) {
                try {
                    this.updateHumidityChart();
                } catch (error) {
                    console.error('Failed to update humidity chart:', error);
                }
            }
            if (this.pressureChart && this.sensorData.length > 0 && !this.chartsDisabled) {
                try {
                    this.updatePressureChart();
                } catch (error) {
                    console.error('Failed to update pressure chart:', error);
                }
            }
        },

        async refreshHistoricalData() {
            await this.updateHistoricalData();
        },
        
        async updatePredictions() {
            // Load predictions for the selected time range
            await this.loadPredictions();
            
            // Update predictions chart if ready and not disabled
            if (this.predictionsChart && this.recentPredictions.length > 0 && !this.chartsDisabled) {
                try {
                    this.updatePredictionsChart();
                } catch (error) {
                    console.error('Failed to update predictions chart:', error);
                }
            }
        },
        
        async refreshAnalysis() {
            this.analysisLoading = {
                timeSeries: true,
                distributions: true,
                correlation: true,
                temporal: true
            };
            
            const timestamp = new Date().getTime();
            const plots = ['time-series-plot', 'distribution-plot', 'correlation-plot', 'temporal-plot'];
            
            for (const plotId of plots) {
                const img = document.getElementById(plotId);
                if (img) {
                    img.src = img.src.split('?')[0] + '?t=' + timestamp;
                    img.onload = () => {
                        this.analysisLoading[plotId.replace('-plot', '')] = false;
                    };
                    img.onerror = () => {
                        this.analysisLoading[plotId.replace('-plot', '')] = false;
                    };
                }
            }
        },
        
        async refreshBenchmark() {
            await this.loadModelMetrics();
        },
        
        async refreshAllData() {
            await this.loadInitialData();
        },
        
        toggleAutoRefresh() {
            this.autoRefreshEnabled = !this.autoRefreshEnabled;
            if (this.autoRefreshEnabled) {
                this.startAutoRefresh();
            } else {
                this.stopAutoRefresh();
            }
        },
        
        startAutoRefresh() {
            if (this.autoRefreshInterval) {
                clearInterval(this.autoRefreshInterval);
            }
            this.autoRefreshInterval = setInterval(() => {
                this.loadPredictions();
                this.loadCurrentWeather();
                this.updateLastUpdateTime();
            }, 10000); // 10 seconds
        },
        
        stopAutoRefresh() {
            if (this.autoRefreshInterval) {
                clearInterval(this.autoRefreshInterval);
                this.autoRefreshInterval = null;
            }
        },
        
        updateLastUpdateTime() {
            this.lastUpdateTime = new Date().toLocaleTimeString();
        },
        
        formatDateTime(timestamp) {
            return new Date(timestamp).toLocaleString();
        },
        
        getConfidenceClass(confidence) {
            if (confidence >= 0.8) return 'confidence-high';
            if (confidence >= 0.6) return 'confidence-medium';
            return 'confidence-low';
        },

        getStatusClass(status) {
            if (status) {
                return 'status-green';
            } else {
                return 'status-red';
            }
        }
    }
}
</script>
{% endblock %} 