{% extends 'base.html' %}
{% block title %}Weather Forecasting{% endblock %}
{% block head %}
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <link rel="stylesheet" href="/static/dashboard.css">
    
    {# Logger Configuration #}
    <div id="logger-config" 
         data-enabled="{{ config.LOGGING_ENABLED | lower }}"
         data-level="{{ config.LOG_LEVEL }}"
         data-verbose="{{ config.LOG_VERBOSE | lower }}"
         style="display: none;"></div>
    <script>
        // Load logger config from data attributes
        const configElement = document.getElementById('logger-config');
        window.LoggerConfig = {
            enabled: configElement.dataset.enabled === 'true',
            level: configElement.dataset.level,
            verbose: configElement.dataset.verbose === 'true'
        };
    </script>
    
    {# Include Logger Component #}
    {% include 'components/logger.html' with context %}
{% endblock %}
{% block content %}
<div x-data="dashboardApp()" class="min-h-screen bg-gray-50">
    <!-- Loading State -->
    <div x-show="isLoading" class="fixed inset-0 bg-white bg-opacity-90 flex items-center justify-center z-50">
        <div class="text-center">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
            <p class="text-gray-600">Loading Weather Dashboard...</p>
        </div>
    </div>

    <!-- Error State -->
    <div x-show="hasError" class="fixed inset-0 bg-white bg-opacity-90 flex items-center justify-center z-50">
        <div class="text-center max-w-md mx-auto p-6">
            <div class="text-red-500 text-6xl mb-4">‚ö†Ô∏è</div>
            <h2 class="text-xl font-semibold text-gray-900 mb-2">Dashboard Error</h2>
            <p class="text-gray-600 mb-4" x-text="errorMessage"></p>
            <button @click="init()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg">
                Retry
            </button>
        </div>
    </div>

    <!-- Header Section -->
    <div class="bg-white shadow-sm border-b">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center py-4 sm:py-6 space-y-4 sm:space-y-0">
                <div class="flex items-center">
                    <div class="text-2xl sm:text-3xl mr-3">üå¶Ô∏è</div>
                    <div>
                        <h1 class="text-xl sm:text-2xl font-bold text-gray-900">Weather Forecasting Dashboard</h1>
                        <p class="text-xs sm:text-sm text-gray-500">Real-time monitoring & predictive analytics</p>
                    </div>
                </div>
                <div class="flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-4 w-full sm:w-auto">
                    <div class="text-xs sm:text-sm text-gray-500">
                        Last updated: <span x-text="lastUpdateTime"></span>
                    </div>
                    <button @click="refreshAllData()" class="bg-blue-600 hover:bg-blue-700 text-white px-3 sm:px-4 py-2 rounded-lg flex items-center justify-center space-x-2 transition-colors text-sm">
                        <span class="refresh-button">üîÑ</span>
                        <span class="hidden sm:inline">Refresh All</span>
                        <span class="sm:hidden">Refresh</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="max-w-7xl mx-auto px-2 sm:px-4 lg:px-8 py-4 sm:py-8">
        <!-- Real-Time Weather Monitoring -->
        <div class="grid grid-cols-1 xl:grid-cols-2 gap-4 sm:gap-8 mb-6 sm:mb-8">
            <!-- Current Conditions -->
            {% include 'components/current_conditions.html' with context %}

            <!-- Model Performance -->
            <div class="bg-white rounded-xl p-4 sm:p-6 card-hover shadow-sm">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-base sm:text-lg font-semibold text-gray-900">üìà Model Performance</h2>
                    <button @click="refreshBenchmark()" class="text-blue-600 hover:text-blue-800 text-xs sm:text-sm">üîÑ Refresh</button>
                </div>
                
                <div class="grid grid-cols-3 gap-2 sm:gap-4">
                    <div class="text-center">
                        <div class="text-lg sm:text-2xl font-bold text-blue-700" x-text="modelMetrics.mae ? modelMetrics.mae.toFixed(3) : '--'"></div>
                        <div class="text-xs sm:text-sm text-gray-600">MAE</div>
                    </div>
                    <div class="text-center">
                        <div class="text-lg sm:text-2xl font-bold text-blue-700" x-text="modelMetrics.rmse ? modelMetrics.rmse.toFixed(3) : '--'"></div>
                        <div class="text-xs sm:text-sm text-gray-600">RMSE</div>
                    </div>
                    <div class="text-center">
                        <div class="text-lg sm:text-2xl font-bold text-blue-700" x-text="modelMetrics.r2 ? modelMetrics.r2.toFixed(3) : '--'"></div>
                        <div class="text-xs sm:text-sm text-gray-600">R¬≤</div>
                    </div>
                </div>
                
                <div x-show="modelMetrics.error" class="mt-4 p-3 bg-red-50 border border-red-200 rounded-lg">
                    <div class="text-xs sm:text-sm text-red-600" x-text="modelMetrics.error"></div>
                </div>
            </div>
        </div>

        <!-- Controls Section -->
        <div class="bg-white rounded-xl p-4 sm:p-6 mb-6 sm:mb-8 shadow-sm">
            <h2 class="text-base sm:text-lg font-semibold text-gray-900 mb-4">üìã Controls & Filters</h2>
            
            <!-- Data Quality Indicator -->
            <div x-show="controls.dataType === 'source' && sensorData.length > 0" class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-lg">
                <div class="flex items-start sm:items-center">
                    <span class="text-blue-600 mr-2 mt-0.5 sm:mt-0">‚ÑπÔ∏è</span>
                    <div class="text-xs sm:text-sm text-blue-800">
                        <div class="font-medium">Raw Source Data Info:</div>
                        <div x-show="sensorData.length > 0">
                            <span x-text="getRawSourceDataQualityText()"></span>
                            <span x-show="controls.selectedModule" x-text="` from module ${controls.selectedModule}`"></span>
                            <span x-show="!controls.selectedModule" x-text="` from all modules`"></span>
                        </div>
                        <div x-show="getRawSourceDataQuality() && getRawSourceDataQuality().quality === 'poor'" class="text-xs text-orange-600 mt-1">
                            ‚ö†Ô∏è Data distribution may be uneven - consider selecting a specific module or using preprocessed data
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3 sm:gap-4">
                <div>
                    <label class="block text-xs sm:text-sm font-medium text-gray-700 mb-2">Time Range</label>
                    <select x-model="controls.timeRange" @change="updateTimeControl()" class="w-full border border-gray-300 rounded-lg px-2 sm:px-3 py-2 text-xs sm:text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <template x-for="option in timeRangeOptions" :key="option.value">
                            <option :value="option.value" x-text="option.label"></option>
                        </template>
                    </select>
                </div>
                
                <div x-show="controls.dataType === 'source'">
                    <label class="block text-xs sm:text-sm font-medium text-gray-700 mb-2">Module</label>
                    <select x-model="controls.selectedModule" @change="updateData()" class="w-full border border-gray-300 rounded-lg px-2 sm:px-3 py-2 text-xs sm:text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="">All Modules</option>
                        <template x-for="module in availableModules" :key="module">
                            <option :value="module" x-text="module"></option>
                        </template>
                    </select>
                </div>
                
                <div>
                    <label class="block text-xs sm:text-sm font-medium text-gray-700 mb-2">Data Type</label>
                    <select x-model="controls.dataType" @change="updateData()" class="w-full border border-gray-300 rounded-lg px-2 sm:px-3 py-2 text-xs sm:text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="preprocessed">Preprocessed</option>
                        <option value="source">Raw Source</option>
                    </select>
                </div>
                

            </div>
        </div>

        <!-- Predictive Analytics Dashboard -->
        <div class="bg-white rounded-xl p-4 sm:p-6 mb-6 sm:mb-8 card-hover shadow-sm">
            <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between mb-4 sm:mb-6 space-y-2 sm:space-y-0">
                <h2 class="text-base sm:text-xl font-semibold text-gray-900">üîÆ Predictive Analytics</h2>
                <div class="flex items-center space-x-2 sm:space-x-4">
                    <div class="text-xs sm:text-sm text-gray-500">
                        Auto-refresh: <span x-text="autoRefreshEnabled ? 'ON' : 'OFF'"></span>
                    </div>
                    <button @click="toggleAutoRefresh()" class="bg-blue-600 hover:bg-blue-700 text-white px-2 sm:px-3 py-1 rounded text-xs sm:text-sm">
                        <span x-text="autoRefreshEnabled ? 'Disable' : 'Enable'"></span>
                    </button>
                </div>
            </div>
            
            <div class="chart-container">
                <div id="predictionsChart"></div>
                <div x-show="chartsDisabled" class="text-center py-8 text-gray-500">
                    <div class="text-2xl mb-2">üìä</div>
                    <p class="text-sm">Predictions chart temporarily disabled</p>
                    <p class="text-xs">Data is still being collected and displayed in the table below</p>
                </div>
            </div>
            
            <!-- Recent Predictions Table -->
            <div class="mt-4 sm:mt-6">
                <h3 class="text-sm sm:text-lg font-semibold text-gray-900 mb-3">Recent Predictions</h3>
                <div class="overflow-x-auto -mx-4 sm:mx-0">
                    <div class="inline-block min-w-full align-middle">
                        <div class="overflow-hidden shadow ring-1 ring-black ring-opacity-5 md:rounded-lg">
                            <table class="min-w-full divide-y divide-gray-200">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th class="px-3 sm:px-6 py-2 sm:py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Timestamp</th>
                                        <th class="px-3 sm:px-6 py-2 sm:py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Predicted Temp</th>
                                        <th class="px-3 sm:px-6 py-2 sm:py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Confidence</th>
                                    </tr>
                                </thead>
                                <tbody class="bg-white divide-y divide-gray-200">
                                    <template x-for="prediction in recentPredictions.slice(0, 5)" :key="prediction.timestamp">
                                        <tr>
                                            <td class="px-3 sm:px-6 py-2 sm:py-4 whitespace-nowrap text-xs sm:text-sm text-gray-900" x-text="formatDateTime(prediction.timestamp)"></td>
                                            <td class="px-3 sm:px-6 py-2 sm:py-4 whitespace-nowrap text-xs sm:text-sm font-semibold text-gray-900" x-text="prediction.predicted_temperature.toFixed(1) + '¬∞C'"></td>
                                            <td class="px-3 sm:px-6 py-2 sm:py-4 whitespace-nowrap">
                                                <span class="prediction-confidence text-xs sm:text-sm" :class="getConfidenceClass(prediction.confidence)" x-text="(prediction.confidence * 100).toFixed(1) + '%'"></span>
                                            </td>
                                        </tr>
                                    </template>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Advanced Data Analysis Suite -->
        <div class="bg-white rounded-xl p-4 sm:p-6 mb-6 sm:mb-8 card-hover shadow-sm">
            <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between mb-4 sm:mb-6 space-y-2 sm:space-y-0">
                <h2 class="text-base sm:text-xl font-semibold text-gray-900">üìä Advanced Data Analysis</h2>
                <button @click="refreshAnalysis()" class="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-1 sm:py-2 px-3 sm:px-4 rounded-lg card-hover text-xs sm:text-sm">
                    üîÑ Refresh Analysis
                </button>
            </div>
            
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 sm:gap-6">
                <template x-for="plot in analysisPlots" :key="plot.id">
                    <div>
                        <h3 class="text-sm sm:text-lg font-semibold text-gray-700 mb-3" x-text="plot.title"></h3>
                        <div class="relative">
                            <img :id="plot.id" :src="plot.src" :alt="plot.title" class="w-full rounded-lg shadow-sm">
                            <div x-show="analysisLoading[plot.key]" class="absolute inset-0 bg-gray-200 loading-skeleton rounded-lg"></div>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- Historical Data Visualization -->
        <div class="bg-white rounded-xl p-4 sm:p-6 mb-6 sm:mb-8 card-hover shadow-sm">
            <h2 class="text-base sm:text-xl font-semibold text-gray-900 mb-4 sm:mb-6">üìà Historical Data Visualization</h2>
            
            <!-- Historical Data Controls -->
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3 sm:gap-4 mb-4 sm:mb-6">
                <div>
                    <label class="block text-xs sm:text-sm font-medium text-gray-700 mb-2">Historical Time Range</label>
                    <select x-model="historicalControls.timeRange" @change="loadSensorData('historical')" class="w-full border border-gray-300 rounded-lg px-2 sm:px-3 py-2 text-xs sm:text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <template x-for="option in historicalTimeRangeOptions" :key="option.value">
                            <option :value="option.value" x-text="option.label"></option>
                        </template>
                    </select>
                </div>
                
                <div x-show="historicalControls.dataType === 'source'">
                    <label class="block text-xs sm:text-sm font-medium text-gray-700 mb-2">Module</label>
                    <select x-model="historicalControls.selectedModule" @change="loadSensorData('historical')" class="w-full border border-gray-300 rounded-lg px-2 sm:px-3 py-2 text-xs sm:text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="">All Modules</option>
                        <template x-for="module in availableModules" :key="module">
                            <option :value="module" x-text="module"></option>
                        </template>
                    </select>
                </div>
                
                <div>
                    <label class="block text-xs sm:text-sm font-medium text-gray-700 mb-2">Historical Data Type</label>
                    <select x-model="historicalControls.dataType" @change="loadSensorData('historical')" class="w-full border border-gray-300 rounded-lg px-2 sm:px-3 py-2 text-xs sm:text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="preprocessed">Preprocessed</option>
                        <option value="source">Raw Source</option>
                    </select>
                </div>
                
                <div class="flex items-end">
                    <button @click="loadSensorData('historical')" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-3 sm:px-4 py-2 rounded-lg transition-colors text-xs sm:text-sm">
                        üîÑ Refresh Historical
                    </button>
                </div>
            </div>
            
            <!-- Historical Data Quality Indicator -->
            <div x-show="historicalControls.dataType === 'source' && sensorData.length > 0" class="mb-4 sm:mb-6 p-3 bg-blue-50 border border-blue-200 rounded-lg">
                <div class="flex items-start sm:items-center">
                    <span class="text-blue-600 mr-2 mt-0.5 sm:mt-0">‚ÑπÔ∏è</span>
                    <div class="text-xs sm:text-sm text-blue-800">
                        <div class="font-medium">Historical Raw Source Data Info:</div>
                        <div x-show="sensorData.length > 0">
                            <span x-text="getHistoricalDataQualityText()"></span>
                            <span x-show="historicalControls.selectedModule" x-text="` from module ${historicalControls.selectedModule}`"></span>
                            <span x-show="!historicalControls.selectedModule" x-text="` from all modules`"></span>
                        </div>
                        <div x-show="getHistoricalDataQuality() && getHistoricalDataQuality().quality === 'poor'" class="text-xs text-orange-600 mt-1">
                            ‚ö†Ô∏è Data distribution may be uneven - consider selecting a specific module or using preprocessed data
                        </div>
                    </div>
                </div>
            </div>

            <!-- Individual Historical Charts -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-4 sm:gap-6">
                <template x-for="chart in historicalCharts" :key="chart.id">
                    <div class="bg-gray-50 rounded-lg p-3 sm:p-4">
                        <h3 class="text-sm sm:text-lg font-semibold text-gray-900 mb-3" x-text="chart.title"></h3>
                        <div class="chart-container">
                            <div :id="chart.id"></div>
                            <div x-show="chartsDisabled" class="text-center py-8 text-gray-500">
                                <div class="text-2xl mb-2" x-text="chart.icon"></div>
                                <p class="text-xs sm:text-sm" x-text="chart.name + ' chart temporarily disabled'"></p>
                            </div>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- System Status Overview -->
        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 sm:gap-6 mb-6 sm:mb-8">
            <template x-for="status in systemStatusItems" :key="status.key">
                <div class="bg-white rounded-xl p-4 sm:p-6 card-hover shadow-sm">
                    <div class="flex items-center justify-between">
                        <div>
                            <p class="text-xs sm:text-sm font-medium text-gray-600" x-text="status.label"></p>
                            <div class="flex items-center mt-2" x-show="status.type === 'status'">
                                <span class="status-dot" :class="getStatusClass(systemStatus[status.key])"></span>
                                <span class="text-xs sm:text-sm font-semibold" x-text="systemStatus[status.key] ? status.trueText : status.falseText"></span>
                            </div>
                            <div class="mt-2" x-show="status.type === 'count'">
                                <span class="text-base sm:text-lg font-bold text-gray-900" x-text="systemStatus[status.key] || 0"></span>
                            </div>
                        </div>
                        <div class="text-xl sm:text-2xl" x-text="status.icon"></div>
                    </div>
                </div>
            </template>
        </div>
    </div>
</div>

<script>
function dashboardApp() {
    return {
        // State
        lastUpdateTime: '--',
        autoRefreshEnabled: false,
        autoRefreshInterval: null,
        isLoading: true,
        hasError: false,
        errorMessage: '',
        chartsDisabled: false, // New flag to disable charts if they cause issues
        
        // Data
        currentWeather: {},
        currentWeatherLoading: false,
        currentWeatherError: null,
        systemStatus: {
            sourceDb: false,
            scheduler: false,
            model: false,
            records: 0
        },
        modelMetrics: {
            mae: null,
            rmse: null,
            r2: null,
            error: null
        },
        recentPredictions: [],
        availableModules: [],
        sensorData: [],
        lastPredictedTemp: null,
        lastPredictedTempTime: null,
        
        // Controls
        controls: {
            timeRange: '6',  // Default to 6 hours as user expects
            selectedModule: '',
            dataType: 'preprocessed'
        },
        
        // Historical Data Controls
        historicalControls: {
            timeRange: '168',  // Changed to '168' (1 week) for historical analysis
            selectedModule: '',
            dataType: 'preprocessed'
        },
        
        // Loading states
        analysisLoading: {
            timeSeries: false,
            distributions: false,
            correlation: false,
            temporal: false
        },
        
        // Charts
        predictionsChart: null,
        temperatureChart: null,
        humidityChart: null,
        pressureChart: null,
        
        // Data structures for templates
        timeRangeOptions: [
            { value: '6', label: 'Last 6 hours' },
            { value: '12', label: 'Last 12 hours' },
            { value: '24', label: 'Last 24 hours' },
            { value: '48', label: 'Last 48 hours' },
            { value: '168', label: 'Last week' },
            { value: '720', label: 'Last month' }
        ],
        
        historicalTimeRangeOptions: [
            { value: '24', label: 'Last 24 hours' },
            { value: '48', label: 'Last 48 hours' },
            { value: '168', label: 'Last week' },
            { value: '720', label: 'Last month' },
            { value: '2160', label: 'Last 3 months' },
            { value: '4320', label: 'Last 6 months' }
        ],
        
        systemStatusItems: [
            { key: 'sourceDb', label: 'Database Status', type: 'status', trueText: 'Healthy', falseText: 'Error', icon: 'üóÑÔ∏è' },
            { key: 'scheduler', label: 'Scheduler Status', type: 'status', trueText: 'Running', falseText: 'Stopped', icon: '‚è∞' },
            { key: 'model', label: 'Model Status', type: 'status', trueText: 'Trained', falseText: 'Not Ready', icon: 'ü§ñ' },
            { key: 'records', label: 'Data Records', type: 'count', icon: 'üìä' }
        ],
        
        historicalCharts: [
            { id: 'temperatureChart', name: 'Temperature', title: 'üå°Ô∏è Temperature', icon: 'üå°Ô∏è', field: 'temperature', color: 'rgb(239, 68, 68)', unit: '¬∞C' },
            { id: 'humidityChart', name: 'Humidity', title: 'üíß Humidity', icon: 'üíß', field: 'humidity', color: 'rgb(59, 130, 246)', unit: '%' },
            { id: 'pressureChart', name: 'Pressure', title: 'üå™Ô∏è Pressure', icon: 'üå™Ô∏è', field: 'pressure', color: 'rgb(34, 197, 94)', unit: 'hPa' }
        ],
        
        analysisPlots: [
            { id: 'time-series-plot', key: 'timeSeries', title: 'Time Series Analysis', src: '/api/analysis/time-series' },
            { id: 'distribution-plot', key: 'distributions', title: 'Data Distributions', src: '/api/analysis/distributions' },
            { id: 'correlation-plot', key: 'correlation', title: 'Correlation Matrix', src: '/api/analysis/correlation' },
            { id: 'temporal-plot', key: 'temporal', title: 'Temporal Patterns', src: '/api/analysis/temporal' }
        ],
        
        // Methods
        async init() {
            try {
                this.isLoading = true;
                this.hasError = false;
                this.errorMessage = '';
                
                window.logger.logInit();
                
                // Wait for Plotly to be available
                let retries = 0;
                while (typeof Plotly === 'undefined' && retries < 10) {
                    window.logger.debug('Waiting for Plotly to load...', { retry: retries });
                    await new Promise(resolve => setTimeout(resolve, 500));
                    retries++;
                }
                
                if (typeof Plotly === 'undefined') {
                    window.logger.error('Plotly failed to load after retries');
                    this.chartsDisabled = true;
                } else {
                    window.logger.info('Plotly loaded successfully');
                }
                
                // Wait for DOM to be ready
                await new Promise(resolve => setTimeout(resolve, 100));
                
                
                
                // Set up charts first
                this.setupCharts();
                
                // Wait a bit for charts to be ready
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Then load data
                await this.loadInitialData();
                
                this.startAutoRefresh();
                this.isLoading = false;
                window.logger.info('Dashboard initialization completed');
            } catch (error) {
                window.logger.logError(error, 'Dashboard initialization failed');
                this.isLoading = false;
                this.hasError = true;
                this.errorMessage = 'Failed to initialize dashboard. Please refresh the page.';
            }
        },
        
        // Helper method to handle API errors including rate limiting
        async handleApiError(response, context = 'API request') {
            if (response.status === 429) {
                // Rate limit exceeded
                const errorData = await response.json().catch(() => ({}));
                const retryAfter = response.headers.get('Retry-After') || errorData.retry_after || 60;
                const message = errorData.message || `Rate limit exceeded. Please wait ${retryAfter} seconds before trying again.`;
                
                window.logger.warn(`Rate limit exceeded: ${message}`);
                
                // Show user-friendly rate limit message
                this.showRateLimitMessage(message, retryAfter);
                return false;
            } else if (response.status >= 500) {
                // Server error
                window.logger.error(`Server error (${response.status}) in ${context}`);
                return false;
            } else if (response.status >= 400) {
                // Client error
                window.logger.warn(`Client error (${response.status}) in ${context}`);
                return false;
            }
            return true;
        },
        
        // Show rate limit message to user
        showRateLimitMessage(message, retryAfter) {
            // Create a temporary notification
            const notification = document.createElement('div');
            notification.className = 'fixed top-4 right-4 bg-yellow-100 border border-yellow-400 text-yellow-700 px-4 py-3 rounded z-50 max-w-sm';
            notification.innerHTML = `
                <div class="flex items-center">
                    <span class="text-yellow-500 mr-2">‚ö†Ô∏è</span>
                    <div>
                        <div class="font-medium">Rate Limit Exceeded</div>
                        <div class="text-sm">${message}</div>
                        <div class="text-xs mt-1">Retry in ${retryAfter} seconds</div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Remove notification after retry time
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, (retryAfter + 5) * 1000);
        },
        
        async loadInitialData() {
            await Promise.all([
                this.loadSystemStatus(),
                this.loadCurrentWeather(),
                this.loadModelMetrics(),
                this.loadModules()
            ]);
            
                            // Load sensor data and predictions
                await this.loadSensorData('regular');
                await this.loadPredictions();
            
            // Update charts after data is loaded
            if (this.sensorData.length > 0 && !this.chartsDisabled) {
                ['Temperature', 'Humidity', 'Pressure'].forEach(chartType => {
                    const chart = this[chartType.toLowerCase() + 'Chart'];
                    if (chart) {
                        try {
                            this.updateChart(chartType);
                        } catch (error) {
                            console.error(`Failed to update ${chartType.toLowerCase()} chart:`, error);
                        }
                    }
                });
            }
            
            this.updateLastUpdateTime();
        },
        
        async loadSystemStatus() {
            try {
                const response = await fetch('/api/stats');
                
                if (!await this.handleApiError(response, 'System status')) {
                    return;
                }
                
                const data = await response.json();
                
                // Check if source database is working
                // Consider it healthy if status is 'online' OR if we have sensor records (indicating successful connection)
                const sourceDbHealthy = data.raw_data?.status === 'online' || 
                                       (data.raw_data?.sensor_records !== undefined && data.raw_data?.sensor_records >= 0);
                
                this.systemStatus = {
                    sourceDb: sourceDbHealthy,
                    scheduler: data.is_running === true,
                    model: data.model_trained === true,
                    records: data.preprocessed_records || 0
                };
            } catch (error) {
                window.logger.logError(error, 'Error loading system status');
                // If we can't even fetch stats, assume database is down
                this.systemStatus = {
                    sourceDb: false,
                    scheduler: false,
                    model: false,
                    records: 0
                };
            }
        },
        
        async loadCurrentWeather() {
            try {
                this.currentWeatherLoading = true;
                this.currentWeatherError = null;
                
                // Try preprocessed data first
                let response = await fetch('/api/preprocessed-data?hours_back=1&limit=1');
                
                if (!await this.handleApiError(response, 'Current weather (preprocessed)')) {
                    this.currentWeatherError = 'Rate limit exceeded - please wait before retrying';
                    return;
                }
                
                let data = await response.json();
                
                if (data.length > 0) {
                    this.currentWeather = {
                        temperature: data[0].temperature,
                        humidity: data[0].humidity,
                        pressure: data[0].pressure,
                        module: 'preprocessed',
                        dataSource: 'preprocessed',
                        timestamp: new Date(data[0].timestamp).toLocaleString(),
                        rawTimestamp: data[0].timestamp
                    };
                } else {
                    // Fallback to source data
                    response = await fetch('/api/sensor-data?hours=1&limit=1');
                    
                    if (!await this.handleApiError(response, 'Current weather (source)')) {
                        this.currentWeatherError = 'Rate limit exceeded - please wait before retrying';
                        return;
                    }
                    
                    data = await response.json();
                    if (data.length > 0) {
                        this.currentWeather = {
                            temperature: data[0].temperature,
                            humidity: data[0].humidity,
                            pressure: data[0].pressure,
                            module: data[0].module,
                            dataSource: 'source',
                            timestamp: new Date(data[0].timestamp).toLocaleString(),
                            rawTimestamp: data[0].timestamp
                        };
                    } else {
                        // No data available, but don't show as error - just leave empty
                        this.currentWeather = {};
                    }
                }
                
                // Calculate trends if we have historical data
                if (this.sensorData && this.sensorData.length > 1) {
                    this.calculateWeatherTrends();
                }
                
            } catch (error) {
                window.logger.logError(error, 'Error loading current weather');
                this.currentWeatherError = 'Failed to load weather data';
            } finally {
                this.currentWeatherLoading = false;
            }
        },
        
        async loadModelMetrics() {
            try {
                const response = await fetch('/api/model/benchmark');
                
                if (!await this.handleApiError(response, 'Model metrics')) {
                    return;
                }
                
                if (response.ok) {
                    const data = await response.json();
                    this.modelMetrics = {
                        mae: data.mae,
                        rmse: data.rmse,
                        r2: data.r2,
                        error: null
                    };
                } else {
                    const errorData = await response.json();
                    this.modelMetrics.error = errorData.error || 'No benchmark data available';
                }
            } catch (error) {
                this.modelMetrics.error = 'Error loading benchmark data';
            }
        },
        
        async loadPredictions() {
            try {
                // Use the time range for predictions as well, not just forecast hours
                const response = await fetch(`/api/predictions?hours=${this.controls.timeRange}`);
                
                if (!await this.handleApiError(response, 'Predictions')) {
                    return;
                }
                
                if (!response.ok) {
                    console.warn('Failed to load predictions:', response.status);
                    this.recentPredictions = [];
                    return;
                }
                const data = await response.json();
                window.logger.logData(data.length, 'Predictions loaded');
                
                // Sort data by timestamp to ensure chronological order
                const sortedData = Array.isArray(data) ? data.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)) : [];
                
                if (sortedData.length > 0) {
                    window.logger.debug('Prediction time range:', new Date(sortedData[0].timestamp), 'to', new Date(sortedData[sortedData.length - 1].timestamp));
                }
                this.recentPredictions = sortedData;
                
                // Set last predicted temperature and time (use the most recent prediction)
                if (this.recentPredictions.length > 0) {
                    // Get the most recent prediction (last in the array since it's sorted by timestamp)
                    const latestPrediction = this.recentPredictions[this.recentPredictions.length - 1];
                    this.lastPredictedTemp = latestPrediction.predicted_temperature;
                    this.lastPredictedTempTime = latestPrediction.timestamp;
                } else {
                    this.lastPredictedTemp = null;
                    this.lastPredictedTempTime = null;
                }
                
                // Only update chart if we have data and chart is ready and not disabled
                if (this.recentPredictions.length > 0 && this.predictionsChart && !this.chartsDisabled) {
                    this.updatePredictionsChart();
                }
            } catch (error) {
                window.logger.logError(error, 'Error loading predictions');
                this.recentPredictions = [];
            }
        },
        
        async loadSensorData(type = 'regular') {
            try {
                // Use historical controls for historical data, regular controls for regular data
                const controls = type === 'historical' ? this.historicalControls : this.controls;
                window.logger.debug(`Loading sensor data (${type}):`, controls);
                
                const moduleParam = controls.selectedModule ? `&module_id=${controls.selectedModule}` : '';
                
                let response;
                let url;
                if (controls.dataType === 'preprocessed') {
                    // Use preprocessed data endpoint
                    url = `/api/preprocessed-data?hours_back=${controls.timeRange}${moduleParam}`;
                    response = await fetch(url);
                } else {
                    // Use source data endpoint
                    url = `/api/sensor-data?hours=${controls.timeRange}${moduleParam}`;
                    response = await fetch(url);
                }
                
                window.logger.debug('Fetching sensor data from:', url);
                
                if (!await this.handleApiError(response, `Sensor data (${controls.dataType})`)) {
                    return;
                }
                
                if (!response.ok) {
                    console.warn('Failed to load sensor data:', response.status);
                    this.sensorData = [];
                    return;
                }
                const data = await response.json();
                window.logger.logData(data.length, 'Sensor data loaded');
                
                // Sort data by timestamp to ensure chronological order
                const sortedData = Array.isArray(data) ? data.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)) : [];
                
                if (sortedData.length > 0) {
                    const startTime = new Date(sortedData[0].timestamp);
                    const endTime = new Date(sortedData[sortedData.length - 1].timestamp);
                    window.logger.debug('Time range:', startTime, 'to', endTime);
                    

                }
                this.sensorData = sortedData;
                
                // Update charts if data is available
                if (this.sensorData.length > 0 && !this.chartsDisabled) {
                    ['Temperature', 'Humidity', 'Pressure'].forEach(chartType => {
                        const chart = this[chartType.toLowerCase() + 'Chart'];
                        if (chart) {
                            try {
                                this.updateChart(chartType);
                            } catch (error) {
                                console.error(`Failed to update ${chartType.toLowerCase()} chart:`, error);
                            }
                        }
                    });
                }
                
                // Calculate weather trends for current conditions (use main sensor data)
                if (this.sensorData.length > 1 && this.currentWeather.temperature) {
                    this.calculateWeatherTrends();
                }
            } catch (error) {
                window.logger.logError(error, 'Error loading sensor data');
                this.sensorData = [];
            }
        },
        
        async loadModules() {
            try {
                const response = await fetch('/api/modules');
                
                if (!await this.handleApiError(response, 'Modules')) {
                    return;
                }
                
                const data = await response.json();
                this.availableModules = data.modules || [];
            } catch (error) {
                window.logger.logError(error, 'Error loading modules');
            }
        },
        
        setupCharts() {
            window.logger.info('Setting up charts...');
            
            if (this.chartsDisabled || typeof Plotly === 'undefined') {
                this.chartsDisabled = true;
                return;
            }
            
            // Define config for all charts
            const config = {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                displaylogo: false
            };
            
            const predictionsCtx = document.getElementById('predictionsChart');
            if (!predictionsCtx) {
                console.error('Predictions chart canvas not found');
                this.chartsDisabled = true;
                return;
            }
            
            try {
                const predictionsData = [
                    {
                        x: [],
                        y: [],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Historical Temperature',
                        line: {
                            color: 'rgb(59, 130, 246)',
                            width: 2
                        },
                        marker: {
                            size: 4,
                            color: 'rgb(59, 130, 246)'
                        },
                        hovertemplate: '%{x}<br>Temperature: %{y:.1f}¬∞C<extra></extra>'
                    },
                    {
                        x: [],
                        y: [],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Predicted Temperature',
                        line: {
                            color: 'rgb(239, 68, 68)',
                            width: 2,
                            dash: 'dash'
                        },
                        marker: {
                            size: 4,
                            color: 'rgb(239, 68, 68)'
                        },
                        hovertemplate: '%{x}<br>Predicted: %{y:.1f}¬∞C<extra></extra>'
                    }
                ];
                
                const predictionsLayout = {
                    title: {
                        text: 'Temperature Predictions vs Historical Data',
                        font: { size: 16 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 12 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Temperature (¬∞C)',
                            font: { size: 12 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    legend: {
                        orientation: 'h',
                        y: 1.1,
                        x: 0.5,
                        xanchor: 'center',
                        bgcolor: 'rgba(255,255,255,0.8)'
                    },
                    height: Math.min(400, window.innerHeight * 0.4),
                    margin: { t: 60, b: 60, l: 60, r: 40 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)',
                    shapes: []
                };
                
                Plotly.newPlot(predictionsCtx, predictionsData, predictionsLayout, config);
                this.predictionsChart = predictionsCtx;
                

            } catch (error) {
                console.error('Error creating predictions chart:', error);
                this.predictionsChart = null;
            }
            
                                                const temperatureCtx = document.getElementById('temperatureChart');
            if (!temperatureCtx) {
                console.error('Temperature chart canvas not found');
                return;
            }
            
            try {
                const temperatureData = [
                    {
                        x: [],
                        y: [],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Temperature',
                        line: {
                            color: 'rgb(239, 68, 68)',
                            width: 2
                        },
                        marker: {
                            size: 3,
                            color: 'rgb(239, 68, 68)'
                        },
                        hovertemplate: '%{x}<br>Temperature: %{y:.1f}¬∞C<extra></extra>'
                    }
                ];
                
                const temperatureLayout = {
                    title: {
                        text: 'Temperature Over Time',
                        font: { size: 14 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 10 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Temperature (¬∞C)',
                            font: { size: 10 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    height: Math.min(300, window.innerHeight * 0.3),
                    margin: { t: 40, b: 40, l: 50, r: 20 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                Plotly.newPlot(temperatureCtx, temperatureData, temperatureLayout, config);
                this.temperatureChart = temperatureCtx;
            } catch (error) {
                console.error('Error creating temperature chart:', error);
            }
            
                                                const humidityCtx = document.getElementById('humidityChart');
            if (!humidityCtx) {
                console.error('Humidity chart canvas not found');
                return;
            }
            
            try {
                const humidityData = [
                    {
                        x: [],
                        y: [],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Humidity',
                        line: {
                            color: 'rgb(59, 130, 246)',
                            width: 2
                        },
                        marker: {
                            size: 3,
                            color: 'rgb(59, 130, 246)'
                        },
                        hovertemplate: '%{x}<br>Humidity: %{y:.1f}%<extra></extra>'
                    }
                ];
                
                const humidityLayout = {
                    title: {
                        text: 'Humidity Over Time',
                        font: { size: 14 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 10 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Humidity (%)',
                            font: { size: 10 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    height: Math.min(300, window.innerHeight * 0.3),
                    margin: { t: 40, b: 40, l: 50, r: 20 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                Plotly.newPlot(humidityCtx, humidityData, humidityLayout, config);
                this.humidityChart = humidityCtx;
            } catch (error) {
                console.error('Error creating humidity chart:', error);
            }
            
                                                const pressureCtx = document.getElementById('pressureChart');
            if (!pressureCtx) {
                console.error('Pressure chart canvas not found');
                return;
            }
            
            try {
                const pressureData = [
                    {
                        x: [],
                        y: [],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Pressure',
                        line: {
                            color: 'rgb(34, 197, 94)',
                            width: 2
                        },
                        marker: {
                            size: 3,
                            color: 'rgb(34, 197, 94)'
                        },
                        hovertemplate: '%{x}<br>Pressure: %{y:.1f}hPa<extra></extra>'
                    }
                ];
                
                const pressureLayout = {
                    title: {
                        text: 'Pressure Over Time',
                    font: { size: 14 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 10 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Pressure (hPa)',
                            font: { size: 10 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    height: Math.min(300, window.innerHeight * 0.3),
                    margin: { t: 40, b: 40, l: 50, r: 20 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                Plotly.newPlot(pressureCtx, pressureData, pressureLayout, config);
                this.pressureChart = pressureCtx;
            } catch (error) {
                console.error('Error creating pressure chart:', error);
            }
        },
        
        updatePredictionsChart() {
            if (this.chartsDisabled || !this.predictionsChart) {
                console.warn('Predictions chart not available or disabled');
                return;
            }
            
            try {
                // Always use main controls for predictions chart - it should respect user's selected time range
                const controls = this.controls;
                const timeRangeHours = parseInt(controls.timeRange);
                const cutoffTime = new Date(Date.now() - timeRangeHours * 60 * 60 * 1000);
                
                // Filter historical data using main controls data
                const historicalData = this.sensorData && this.sensorData.length > 0 ? 
                    this.sensorData.filter(d => new Date(d.timestamp) >= cutoffTime) : [];
                
                // Filter prediction data
                const predictionData = this.recentPredictions && this.recentPredictions.length > 0 ? 
                    this.recentPredictions.filter(d => new Date(d.timestamp) >= cutoffTime) : [];
                
                // Create data arrays for Plotly with proper timestamp handling
                const historicalX = historicalData.map(d => new Date(d.timestamp));
                const historicalY = historicalData.map(d => Number(d.temperature) || 0);
                
                const predictionX = predictionData.map(d => new Date(d.timestamp));
                const predictionY = predictionData.map(d => Number(d.predicted_temperature) || 0);
                
                // If we have no data at all, don't update the chart
                if (historicalX.length === 0 && predictionX.length === 0) {
                    console.warn('No data available for predictions chart');
                    return;
                }
                

                
                this.replotPredictionsChart(historicalX, historicalY, predictionX, predictionY);
                
            } catch (error) {
                console.error('Error updating predictions chart:', error);
            }
        },
        
        replotPredictionsChart(historicalX, historicalY, predictionX, predictionY) {
            try {
                const plotData = [
                    {
                        x: historicalX,
                        y: historicalY,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Historical Temperature',
                        line: {
                            color: 'rgb(59, 130, 246)',
                            width: 2
                        },
                        marker: {
                            size: 4,
                            color: 'rgb(59, 130, 246)'
                        },
                        hovertemplate: '%{x}<br>Temperature: %{y:.1f}¬∞C<extra></extra>'
                    },
                    {
                        x: predictionX,
                        y: predictionY,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Predicted Temperature',
                        line: {
                            color: 'rgb(239, 68, 68)',
                            width: 2,
                            dash: 'dash'
                        },
                        marker: {
                            size: 4,
                            color: 'rgb(239, 68, 68)'
                        },
                        hovertemplate: '%{x}<br>Predicted: %{y:.1f}¬∞C<extra></extra>'
                    }
                ];
                
                const shapes = [];
                
                const layout = {
                    title: {
                        text: 'Temperature Predictions vs Historical Data',
                        font: { size: 16 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 12 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Temperature (¬∞C)',
                            font: { size: 12 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    legend: {
                        orientation: 'h',
                        y: 1.1,
                        x: 0.5,
                        xanchor: 'center',
                        bgcolor: 'rgba(255,255,255,0.8)'
                    },
                    height: Math.min(400, window.innerHeight * 0.4),
                    margin: { t: 60, b: 60, l: 60, r: 40 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)',
                    shapes: shapes
                };
                
                const config = {
                    responsive: true,
                    displayModeBar: true,
                    modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                    displaylogo: false
                };
                
                Plotly.newPlot(this.predictionsChart, plotData, layout, config);

            } catch (error) {
                console.error('Error replotting predictions chart:', error);
            }
        },
        
        updateChart(chartType) {
            const chart = this.historicalCharts.find(c => c.name.toLowerCase() === chartType.toLowerCase());
            if (!chart) {
                window.logger.warn(`Chart type ${chartType} not found`);
                return;
            }
            
            // Get the correct chart element reference
            const chartElement = this[chart.id];
            
            if (this.chartsDisabled || !chartElement) {
                window.logger.warn(`${chartType} chart not available or disabled`);
                return;
            }
            
            try {
                if (!this.sensorData || this.sensorData.length === 0) {
                    window.logger.warn(`No sensor data available for ${chartType} chart`);
                    return;
                }
                
                // Use historical controls for historical charts
                const controls = this.historicalControls;
                const timeRangeHours = parseInt(controls.timeRange);
                const cutoffTime = new Date(Date.now() - timeRangeHours * 60 * 60 * 1000);
                
                const filteredData = this.sensorData.filter(d => {
                    const dataTime = new Date(d.timestamp);
                    return dataTime >= cutoffTime;
                });
                
                window.logger.logData(filteredData.length, `${chartType} chart data points (filtered for ${timeRangeHours} hours)`);
                
                if (filteredData.length === 0) {
                    window.logger.warn(`No data within ${timeRangeHours} hours for ${chartType} chart`);
                    return;
                }
                
                // Create data arrays for Plotly with proper timestamp handling
                const x = filteredData.map(d => new Date(d.timestamp));
                const values = filteredData.map(d => Number(d[chart.field]) || 0);
                
                // Replot the chart
                this.replotChart(chart, x, values);
                
            } catch (error) {
                window.logger.logError(error, `${chartType} chart update failed`);
                this.disableChart(chart.id);
            }
        },
        
        replotChart(chart, x, values) {
            try {
                
                const plotData = [
                    {
                        x: x,
                        y: values,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: chart.name,
                        line: {
                            color: chart.color,
                            width: 2
                        },
                        marker: {
                            size: 3,
                            color: chart.color
                        },
                        hovertemplate: `%{x}<br>${chart.name}: %{y:.1f}${chart.unit}<extra></extra>`
                    }
                ];
                
                const layout = {
                    title: {
                        text: `${chart.name} Over Time`,
                        font: { size: 14 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 10 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: `${chart.name} (${chart.unit})`,
                            font: { size: 10 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    height: Math.min(300, window.innerHeight * 0.3),
                    margin: { t: 40, b: 40, l: 50, r: 20 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                const config = {
                    responsive: true,
                    displayModeBar: true,
                    modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                    displaylogo: false
                };
                
                const chartElement = this[chart.id];
                Plotly.newPlot(chartElement, plotData, layout, config);
                
            } catch (error) {
                console.error(`${chart.name} chart replot failed:`, error);
            }
        },
        

        

        
        async updateData() {
            await this.loadSensorData('regular');
            await this.loadPredictions();
            await this.loadCurrentWeather();
            
            // Update charts if data is available
            if (this.sensorData.length > 0 && !this.chartsDisabled) {
                ['Temperature', 'Humidity', 'Pressure'].forEach(chartType => {
                    const chart = this[chartType.toLowerCase() + 'Chart'];
                    if (chart) {
                        try {
                            this.updateChart(chartType);
                        } catch (error) {
                            console.error(`Failed to update ${chartType.toLowerCase()} chart:`, error);
                        }
                    }
                });
            }
            
            // Update predictions chart if ready and not disabled
            if (this.predictionsChart && this.recentPredictions.length > 0 && !this.chartsDisabled) {
                try {
                    this.updatePredictionsChart();
                } catch (error) {
                    console.error('Failed to update predictions chart:', error);
                }
            }
        },
        
        // New method specifically for time control updates - only updates what's needed
        async updateTimeControl() {
            // Only update sensor data and predictions when time control changes
            // Don't update current weather as it's not affected by time range
            await this.loadSensorData('regular');
            await this.loadPredictions();
            
            // Update charts if data is available
            if (this.sensorData.length > 0 && !this.chartsDisabled) {
                ['Temperature', 'Humidity', 'Pressure'].forEach(chartType => {
                    const chart = this[chartType.toLowerCase() + 'Chart'];
                    if (chart) {
                        try {
                            this.updateChart(chartType);
                        } catch (error) {
                            console.error(`Failed to update ${chartType.toLowerCase()} chart:`, error);
                        }
                    }
                });
            }
            
            // Update predictions chart if ready and not disabled
            if (this.predictionsChart && this.recentPredictions.length > 0 && !this.chartsDisabled) {
                try {
                    this.updatePredictionsChart();
                } catch (error) {
                    console.error('Failed to update predictions chart:', error);
                }
            }
        },
        

        

        async refreshAnalysis() {
            this.analysisLoading = {
                timeSeries: true,
                distributions: true,
                correlation: true,
                temporal: true
            };
            
            const timestamp = new Date().getTime();
            const plots = ['time-series-plot', 'distribution-plot', 'correlation-plot', 'temporal-plot'];
            
            for (const plotId of plots) {
                const img = document.getElementById(plotId);
                if (img) {
                    img.src = img.src.split('?')[0] + '?t=' + timestamp;
                    img.onload = () => {
                        this.analysisLoading[plotId.replace('-plot', '')] = false;
                    };
                    img.onerror = () => {
                        this.analysisLoading[plotId.replace('-plot', '')] = false;
                    };
                }
            }
        },
        
        async refreshBenchmark() {
            await this.loadModelMetrics();
        },
        
        async refreshAllData() {
            await this.loadInitialData();
        },
        
        toggleAutoRefresh() {
            this.autoRefreshEnabled = !this.autoRefreshEnabled;
            if (this.autoRefreshEnabled) {
                this.startAutoRefresh();
            } else {
                this.stopAutoRefresh();
            }
        },
        
        startAutoRefresh() {
            if (this.autoRefreshInterval) {
                clearInterval(this.autoRefreshInterval);
            }
            this.autoRefreshInterval = setInterval(() => {
                this.loadPredictions();
                this.loadCurrentWeather();
                this.updateLastUpdateTime();
            }, 60000); // 1 minute (60 seconds)
        },
        
        stopAutoRefresh() {
            if (this.autoRefreshInterval) {
                clearInterval(this.autoRefreshInterval);
                this.autoRefreshInterval = null;
            }
        },
        
        updateLastUpdateTime() {
            this.lastUpdateTime = new Date().toLocaleTimeString();
        },
        
        formatDateTime(timestamp) {
            return new Date(timestamp).toLocaleString();
        },
        
        getConfidenceClass(confidence) {
            if (confidence >= 0.7) return 'confidence-high';
            if (confidence >= 0.5) return 'confidence-medium';
            return 'confidence-low';
        },

        getStatusClass(status) {
            if (status) {
                return 'status-green';
            } else {
                return 'status-red';
            }
        },
        
        calculateWeatherTrends() {
            if (!this.sensorData || this.sensorData.length < 2) return;
            
            // Get last 3 data points for trend calculation
            const recentData = this.sensorData.slice(-3);
            
            // Calculate temperature trend
            if (recentData.length >= 2) {
                const tempDiff = recentData[recentData.length - 1].temperature - recentData[0].temperature;
                if (Math.abs(tempDiff) < 0.5) {
                    this.currentWeather.temperatureTrend = 'stable';
                } else {
                    this.currentWeather.temperatureTrend = tempDiff > 0 ? 'up' : 'down';
                }
            }
            
            // Calculate pressure trend
            if (recentData.length >= 2) {
                const pressureDiff = recentData[recentData.length - 1].pressure - recentData[0].pressure;
                if (Math.abs(pressureDiff) < 1) {
                    this.currentWeather.pressureTrend = 'stable';
                } else {
                    this.currentWeather.pressureTrend = pressureDiff > 0 ? 'up' : 'down';
                }
            }
        },
        
        getWeatherSummary() {
            if (!this.currentWeather.temperature) return 'Weather data unavailable';
            
            const temp = this.currentWeather.temperature;
            const humidity = this.currentWeather.humidity;
            
            if (temp >= 30) return 'Hot';
            if (temp >= 25) return 'Warm';
            if (temp >= 20) return 'Mild';
            if (temp >= 15) return 'Cool';
            if (temp >= 10) return 'Cold';
            return 'Very Cold';
        },
        
        getWeatherDescription() {
            if (!this.currentWeather.temperature) return '';
            
            const temp = this.currentWeather.temperature;
            const humidity = this.currentWeather.humidity;
            
            if (temp >= 30 && humidity >= 80) return 'Hot and Humid';
            if (temp >= 30) return 'Hot and Dry';
            if (temp >= 25 && humidity >= 80) return 'Warm and Humid';
            if (temp >= 25) return 'Warm and Pleasant';
            if (temp >= 20 && humidity >= 80) return 'Mild and Humid';
            if (temp >= 20) return 'Mild and Comfortable';
            if (temp >= 15) return 'Cool and Refreshing';
            if (temp >= 10) return 'Cold';
            return 'Very Cold';
        },
        
        getDataAge() {
            if (!this.currentWeather.rawTimestamp) return 'Unknown';
            
            const now = new Date();
            const dataTime = new Date(this.currentWeather.rawTimestamp);
            const diffMs = now - dataTime;
            const diffMinutes = Math.floor(diffMs / (1000 * 60));
            
            if (diffMinutes < 1) return 'Just now';
            if (diffMinutes < 60) return `${diffMinutes} min ago`;
            
            const diffHours = Math.floor(diffMinutes / 60);
            if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
            
            const diffDays = Math.floor(diffHours / 24);
            return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
        },
        
        getDataQualityClass() {
            if (!this.currentWeather.rawTimestamp) return 'bg-gray-100';
            
            const now = new Date();
            const dataTime = new Date(this.currentWeather.rawTimestamp);
            const diffMs = now - dataTime;
            const diffMinutes = Math.floor(diffMs / (1000 * 60));
            
            if (diffMinutes <= 5) return 'bg-green-100 text-green-800';
            if (diffMinutes <= 15) return 'bg-yellow-100 text-yellow-800';
            return 'bg-red-100 text-red-800';
        },
        
        getDataQualityText() {
            if (!this.currentWeather.rawTimestamp) return 'Data quality: Unknown';
            
            const now = new Date();
            const dataTime = new Date(this.currentWeather.rawTimestamp);
            const diffMs = now - dataTime;
            const diffMinutes = Math.floor(diffMs / (1000 * 60));
            
            if (diffMinutes <= 5) return '‚úÖ Data quality: Excellent (Recent)';
            if (diffMinutes <= 15) return '‚ö†Ô∏è Data quality: Good (Somewhat old)';
            return '‚ùå Data quality: Poor (Outdated)';
        },
        
        getRawSourceDataQuality() {
            if (this.controls.dataType !== 'source' || this.sensorData.length === 0) {
                return null;
            }
            
            const data = this.sensorData;
            const timeSpan = (new Date(data[data.length - 1].timestamp) - new Date(data[0].timestamp)) / (1000 * 60 * 60); // hours
            const avgInterval = timeSpan / (data.length - 1); // hours between points
            
            // Calculate gaps
            const gaps = [];
            for (let i = 1; i < data.length; i++) {
                const prevTime = new Date(data[i-1].timestamp);
                const currTime = new Date(data[i].timestamp);
                const gap = (currTime - prevTime) / (1000 * 60 * 60); // hours
                if (gap > 2) {
                    gaps.push(gap);
                }
            }
            
            return {
                totalPoints: data.length,
                timeSpan: timeSpan,
                avgInterval: avgInterval,
                gaps: gaps.length,
                maxGap: gaps.length > 0 ? Math.max(...gaps) : 0,
                quality: avgInterval <= 0.5 ? 'good' : avgInterval <= 1 ? 'fair' : 'poor'
            };
        },
        
        getRawSourceDataQualityText() {
            const quality = this.getRawSourceDataQuality();
            if (!quality) return '';
            
            let text = `${quality.totalPoints} points over ${quality.timeSpan.toFixed(1)}h`;
            text += ` (avg: ${quality.avgInterval.toFixed(2)}h)`;
            
            if (quality.gaps > 0) {
                text += ` - ${quality.gaps} gaps (max: ${quality.maxGap.toFixed(1)}h)`;
            }
            
            return text;
        },
        
        getHistoricalDataQuality() {
            if (this.historicalControls.dataType !== 'source' || this.sensorData.length === 0) {
                return null;
            }
            
            const data = this.sensorData;
            const timeSpan = (new Date(data[data.length - 1].timestamp) - new Date(data[0].timestamp)) / (1000 * 60 * 60); // hours
            const avgInterval = timeSpan / (data.length - 1); // hours between points
            
            // Calculate gaps
            const gaps = [];
            for (let i = 1; i < data.length; i++) {
                const prevTime = new Date(data[i-1].timestamp);
                const currTime = new Date(data[i].timestamp);
                const gap = (currTime - prevTime) / (1000 * 60 * 60); // hours
                if (gap > 2) {
                    gaps.push(gap);
                }
            }
            
            return {
                totalPoints: data.length,
                timeSpan: timeSpan,
                avgInterval: avgInterval,
                gaps: gaps.length,
                maxGap: gaps.length > 0 ? Math.max(...gaps) : 0,
                quality: avgInterval <= 0.5 ? 'good' : avgInterval <= 1 ? 'fair' : 'poor'
            };
        },
        
        getHistoricalDataQualityText() {
            const quality = this.getHistoricalDataQuality();
            if (!quality) return '';
            
            let text = `${quality.totalPoints} points over ${quality.timeSpan.toFixed(1)}h`;
            text += ` (avg: ${quality.avgInterval.toFixed(2)}h)`;
            
            if (quality.gaps > 0) {
                text += ` - ${quality.gaps} gaps (max: ${quality.maxGap.toFixed(1)}h)`;
            }
            
            return text;
        }
    }
}
</script>
{% endblock %} 