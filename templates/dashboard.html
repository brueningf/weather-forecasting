{% extends 'base.html' %}
{% block title %}Weather Forecasting Dashboard{% endblock %}
{% block head %}
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <link rel="stylesheet" href="/static/dashboard.css">
    <style>
        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .card-hover {
            transition: all 0.3s ease-in-out;
        }
        .card-hover:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .status-green { background-color: #10B981; }
        .status-red { background-color: #EF4444; }
        .status-gray { background-color: #6B7280; }
        .loading-skeleton {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
        }
        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
        }
        .refresh-button {
            transition: all 0.2s ease;
        }
        .refresh-button:hover {
            transform: rotate(180deg);
        }
        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .metric-value {
            font-size: 2rem;
            font-weight: bold;
        }
        .metric-label {
            font-size: 0.875rem;
            opacity: 0.9;
        }
        .prediction-confidence {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        .confidence-high { background-color: #10B981; color: white; }
        .confidence-medium { background-color: #F59E0B; color: white; }
        .confidence-low { background-color: #EF4444; color: white; }
    </style>
{% endblock %}
{% block content %}
<div x-data="dashboardApp()" class="min-h-screen bg-gray-50">
    <!-- Loading State -->
    <div x-show="isLoading" class="fixed inset-0 bg-white bg-opacity-90 flex items-center justify-center z-50">
        <div class="text-center">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
            <p class="text-gray-600">Loading Weather Dashboard...</p>
        </div>
    </div>

    <!-- Error State -->
    <div x-show="hasError" class="fixed inset-0 bg-white bg-opacity-90 flex items-center justify-center z-50">
        <div class="text-center max-w-md mx-auto p-6">
            <div class="text-red-500 text-6xl mb-4">‚ö†Ô∏è</div>
            <h2 class="text-xl font-semibold text-gray-900 mb-2">Dashboard Error</h2>
            <p class="text-gray-600 mb-4" x-text="errorMessage"></p>
            <button @click="init()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg">
                Retry
            </button>
        </div>
    </div>

    <!-- Header Section -->
    <div class="bg-white shadow-sm border-b">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center py-6">
                <div class="flex items-center">
                    <div class="text-3xl mr-3">üå¶Ô∏è</div>
                    <div>
                        <h1 class="text-2xl font-bold text-gray-900">Weather Forecasting Dashboard</h1>
                        <p class="text-sm text-gray-500">Real-time monitoring & predictive analytics</p>
                    </div>
                </div>
                <div class="flex items-center space-x-4">
                    <div class="text-sm text-gray-500">
                        Last updated: <span x-text="lastUpdateTime"></span>
                    </div>
                    <button @click="refreshAllData()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg flex items-center space-x-2 transition-colors">
                        <span class="refresh-button">üîÑ</span>
                        <span>Refresh All</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <!-- Real-Time Weather Monitoring -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
            <!-- Current Conditions -->
            <div class="bg-white rounded-xl p-6 card-hover shadow-sm">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-semibold text-gray-900">üå°Ô∏è Current Conditions</h2>
                    <div class="text-sm text-gray-500" x-text="'Updated: ' + lastUpdateTime"></div>
                </div>
                
                <div class="grid grid-cols-3 gap-4">
                    <div class="text-center">
                        <div class="text-3xl font-bold text-red-600" x-text="currentWeather.temperature ? currentWeather.temperature.toFixed(1) + '¬∞C' : '--'"></div>
                        <div class="text-sm text-gray-600">Temperature</div>
                    </div>
                    <div class="text-center">
                        <div class="text-3xl font-bold text-blue-600" x-text="currentWeather.humidity ? currentWeather.humidity.toFixed(1) + '%' : '--'"></div>
                        <div class="text-sm text-gray-600">Humidity</div>
                    </div>
                    <div class="text-center">
                        <div class="text-3xl font-bold text-green-600" x-text="currentWeather.pressure ? currentWeather.pressure.toFixed(1) + 'hPa' : '--'"></div>
                        <div class="text-sm text-gray-600">Pressure</div>
                    </div>
                </div>
                
                <!-- Last Predicted Temperature -->
                <div class="mt-4 p-3 bg-gradient-to-r from-purple-50 to-blue-50 rounded-lg border border-purple-200">
                    <div class="text-center">
                        <div class="text-2xl font-bold text-purple-700" x-text="lastPredictedTemp ? lastPredictedTemp.toFixed(1) + '¬∞C' : '--'"></div>
                        <div class="text-sm text-purple-600">Last Predicted Temperature</div>
                        <div class="text-xs text-purple-500 mt-1" x-text="lastPredictedTempTime ? 'Predicted at: ' + formatDateTime(lastPredictedTempTime) : ''"></div>
                    </div>
                </div>
                
                <div class="mt-4 p-3 bg-gray-50 rounded-lg">
                    <div class="text-sm text-gray-600">
                        <strong>Module:</strong> <span x-text="currentWeather.module || 'Unknown'"></span>
                    </div>
                    <div class="text-sm text-gray-600">
                        <strong>Timestamp:</strong> <span x-text="currentWeather.timestamp || '--'"></span>
                    </div>
                </div>
            </div>

            <!-- Model Performance -->
            <div class="bg-white rounded-xl p-6 card-hover shadow-sm">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-semibold text-gray-900">üìà Model Performance</h2>
                    <button @click="refreshBenchmark()" class="text-blue-600 hover:text-blue-800 text-sm">üîÑ Refresh</button>
                </div>
                
                <div class="grid grid-cols-3 gap-4">
                    <div class="text-center">
                        <div class="text-2xl font-bold text-blue-700" x-text="modelMetrics.mae ? modelMetrics.mae.toFixed(3) : '--'"></div>
                        <div class="text-sm text-gray-600">MAE</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-blue-700" x-text="modelMetrics.rmse ? modelMetrics.rmse.toFixed(3) : '--'"></div>
                        <div class="text-sm text-gray-600">RMSE</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-blue-700" x-text="modelMetrics.r2 ? modelMetrics.r2.toFixed(3) : '--'"></div>
                        <div class="text-sm text-gray-600">R¬≤</div>
                    </div>
                </div>
                
                <div x-show="modelMetrics.error" class="mt-4 p-3 bg-red-50 border border-red-200 rounded-lg">
                    <div class="text-sm text-red-600" x-text="modelMetrics.error"></div>
                </div>
            </div>
        </div>

        <!-- Controls Section -->
        <div class="bg-white rounded-xl p-6 mb-8 shadow-sm">
            <h2 class="text-lg font-semibold text-gray-900 mb-4">üìã Controls & Filters</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Time Range</label>
                    <select x-model="controls.timeRange" @change="updateData()" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="6">Last 6 hours</option>
                        <option value="12">Last 12 hours</option>
                        <option value="24">Last 24 hours</option>
                        <option value="48">Last 48 hours</option>
                        <option value="168">Last week</option>
                        <option value="720">Last month</option>
                    </select>
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Sensor Module</label>
                    <select x-model="controls.selectedModule" @change="updateData()" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="">All Modules</option>
                        <template x-for="module in availableModules" :key="module">
                            <option :value="module" x-text="module"></option>
                        </template>
                    </select>
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Data Type</label>
                    <select x-model="controls.dataType" @change="updateData()" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="preprocessed">Preprocessed</option>
                        <option value="source">Raw Source</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Predictive Analytics Dashboard -->
        <div class="bg-white rounded-xl p-6 mb-8 card-hover shadow-sm">
            <div class="flex items-center justify-between mb-6">
                <h2 class="text-xl font-semibold text-gray-900">üîÆ Predictive Analytics</h2>
                <div class="flex items-center space-x-4">
                    <div class="text-sm text-gray-500">
                        Auto-refresh: <span x-text="autoRefreshEnabled ? 'ON' : 'OFF'"></span>
                    </div>
                    <button @click="toggleAutoRefresh()" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm">
                        <span x-text="autoRefreshEnabled ? 'Disable' : 'Enable'"></span>
                    </button>
                </div>
            </div>
            
            <div class="chart-container">
                <div id="predictionsChart"></div>
                <div x-show="chartsDisabled" class="text-center py-8 text-gray-500">
                    <div class="text-2xl mb-2">üìä</div>
                    <p>Predictions chart temporarily disabled</p>
                    <p class="text-sm">Data is still being collected and displayed in the table below</p>
                </div>
            </div>
            
            <!-- Recent Predictions Table -->
            <div class="mt-6">
                <h3 class="text-lg font-semibold text-gray-900 mb-3">Recent Predictions</h3>
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Timestamp</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Predicted Temp</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Confidence</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
                            <template x-for="prediction in recentPredictions.slice(0, 5)" :key="prediction.timestamp">
                                <tr>
                                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900" x-text="formatDateTime(prediction.timestamp)"></td>
                                    <td class="px-6 py-4 whitespace-nowrap text-sm font-semibold text-gray-900" x-text="prediction.predicted_temperature.toFixed(1) + '¬∞C'"></td>
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <span class="prediction-confidence" :class="getConfidenceClass(prediction.confidence)" x-text="(prediction.confidence * 100).toFixed(1) + '%'"></span>
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <span class="status-dot status-green"></span>
                                        <span class="text-sm text-gray-900">Active</span>
                                    </td>
                                </tr>
                            </template>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Advanced Data Analysis Suite -->
        <div class="bg-white rounded-xl p-6 mb-8 card-hover shadow-sm">
            <div class="flex items-center justify-between mb-6">
                <h2 class="text-xl font-semibold text-gray-900">üìä Advanced Data Analysis</h2>
                <button @click="refreshAnalysis()" class="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg card-hover">
                    üîÑ Refresh Analysis
                </button>
            </div>
            
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div>
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Time Series Analysis</h3>
                    <div class="relative">
                        <img id="time-series-plot" src="/api/analysis/time-series" alt="Time Series Analysis" class="w-full rounded-lg shadow-sm">
                        <div x-show="analysisLoading.timeSeries" class="absolute inset-0 bg-gray-200 loading-skeleton rounded-lg"></div>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Data Distributions</h3>
                    <div class="relative">
                        <img id="distribution-plot" src="/api/analysis/distributions" alt="Data Distributions" class="w-full rounded-lg shadow-sm">
                        <div x-show="analysisLoading.distributions" class="absolute inset-0 bg-gray-200 loading-skeleton rounded-lg"></div>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Correlation Matrix</h3>
                    <div class="relative">
                        <img id="correlation-plot" src="/api/analysis/correlation" alt="Correlation Matrix" class="w-full rounded-lg shadow-sm">
                        <div x-show="analysisLoading.correlation" class="absolute inset-0 bg-gray-200 loading-skeleton rounded-lg"></div>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">Temporal Patterns</h3>
                    <div class="relative">
                        <img id="temporal-plot" src="/api/analysis/temporal" alt="Temporal Patterns" class="w-full rounded-lg shadow-sm">
                        <div x-show="analysisLoading.temporal" class="absolute inset-0 bg-gray-200 loading-skeleton rounded-lg"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Historical Data Visualization -->
        <div class="bg-white rounded-xl p-6 mb-8 card-hover shadow-sm">
            <h2 class="text-xl font-semibold text-gray-900 mb-6">üìà Historical Data Visualization</h2>
            
            <!-- Historical Data Controls -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Historical Time Range</label>
                    <select x-model="historicalControls.timeRange" @change="updateHistoricalData()" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="6">Last 6 hours</option>
                        <option value="12">Last 12 hours</option>
                        <option value="24">Last 24 hours</option>
                        <option value="48">Last 48 hours</option>
                        <option value="168">Last week</option>
                        <option value="720">Last month</option>
                    </select>
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Historical Module</label>
                    <select x-model="historicalControls.selectedModule" @change="updateHistoricalData()" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="">All Modules</option>
                        <template x-for="module in availableModules" :key="module">
                            <option :value="module" x-text="module"></option>
                        </template>
                    </select>
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Historical Data Type</label>
                    <select x-model="historicalControls.dataType" @change="updateHistoricalData()" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="preprocessed">Preprocessed</option>
                        <option value="source">Raw Source</option>
                    </select>
                </div>
                
                <div class="flex items-end">
                    <button @click="refreshHistoricalData()" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition-colors">
                        üîÑ Refresh Historical
                    </button>
                </div>
            </div>
            
            <!-- Individual Historical Charts -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <!-- Temperature Chart -->
                <div class="bg-gray-50 rounded-lg p-4">
                    <h3 class="text-lg font-semibold text-gray-900 mb-3">üå°Ô∏è Temperature</h3>
                    <div class="chart-container" style="height: 300px;">
                        <div id="temperatureChart"></div>
                        <div x-show="chartsDisabled" class="text-center py-8 text-gray-500">
                            <div class="text-2xl mb-2">üå°Ô∏è</div>
                            <p>Temperature chart temporarily disabled</p>
                        </div>
                    </div>
                </div>
                
                <!-- Humidity Chart -->
                <div class="bg-gray-50 rounded-lg p-4">
                    <h3 class="text-lg font-semibold text-gray-900 mb-3">üíß Humidity</h3>
                    <div class="chart-container" style="height: 300px;">
                        <div id="humidityChart"></div>
                        <div x-show="chartsDisabled" class="text-center py-8 text-gray-500">
                            <div class="text-2xl mb-2">üíß</div>
                            <p>Humidity chart temporarily disabled</p>
                        </div>
                    </div>
                </div>
                
                <!-- Pressure Chart -->
                <div class="bg-gray-50 rounded-lg p-4">
                    <h3 class="text-lg font-semibold text-gray-900 mb-3">üå™Ô∏è Pressure</h3>
                    <div class="chart-container" style="height: 300px;">
                        <div id="pressureChart"></div>
                        <div x-show="chartsDisabled" class="text-center py-8 text-gray-500">
                            <div class="text-2xl mb-2">üå™Ô∏è</div>
                            <p>Pressure chart temporarily disabled</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- System Status Overview (Moved to end) -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
            <div class="bg-white rounded-xl p-6 card-hover shadow-sm">
                <div class="flex items-center justify-between">
                    <div>
                        <p class="text-sm font-medium text-gray-600">Database Status</p>
                        <div class="flex items-center mt-2">
                            <span class="status-dot" :class="getStatusClass(systemStatus.sourceDb)"></span>
                            <span class="text-sm font-semibold" x-text="systemStatus.sourceDb ? 'Healthy' : 'Error'"></span>
                        </div>
                    </div>
                    <div class="text-2xl">üóÑÔ∏è</div>
                </div>
            </div>
            
            <div class="bg-white rounded-xl p-6 card-hover shadow-sm">
                <div class="flex items-center justify-between">
                    <div>
                        <p class="text-sm font-medium text-gray-600">Scheduler Status</p>
                        <div class="flex items-center mt-2">
                            <span class="status-dot" :class="getStatusClass(systemStatus.scheduler)"></span>
                            <span class="text-sm font-semibold" x-text="systemStatus.scheduler ? 'Running' : 'Stopped'"></span>
                        </div>
                    </div>
                    <div class="text-2xl">‚è∞</div>
                </div>
            </div>
            
            <div class="bg-white rounded-xl p-6 card-hover shadow-sm">
                <div class="flex items-center justify-between">
                    <div>
                        <p class="text-sm font-medium text-gray-600">Model Status</p>
                        <div class="flex items-center mt-2">
                            <span class="status-dot" :class="getStatusClass(systemStatus.model)"></span>
                            <span class="text-sm font-semibold" x-text="systemStatus.model ? 'Trained' : 'Not Ready'"></span>
                        </div>
                    </div>
                    <div class="text-2xl">ü§ñ</div>
                </div>
            </div>
            
            <div class="bg-white rounded-xl p-6 card-hover shadow-sm">
                <div class="flex items-center justify-between">
                    <div>
                        <p class="text-sm font-medium text-gray-600">Data Records</p>
                        <div class="mt-2">
                            <span class="text-lg font-bold text-gray-900" x-text="systemStatus.records || 0"></span>
                        </div>
                    </div>
                    <div class="text-2xl">üìä</div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
function dashboardApp() {
    return {
        // State
        lastUpdateTime: '--',
        autoRefreshEnabled: false,
        autoRefreshInterval: null,
        isLoading: true,
        hasError: false,
        errorMessage: '',
        chartsDisabled: false, // New flag to disable charts if they cause issues
        
        // Data
        currentWeather: {},
        systemStatus: {
            sourceDb: false,
            scheduler: false,
            model: false,
            records: 0
        },
        modelMetrics: {
            mae: null,
            rmse: null,
            r2: null,
            error: null
        },
        recentPredictions: [],
        availableModules: [],
        sensorData: [],
        lastPredictedTemp: null,
        lastPredictedTempTime: null,
        
        // Controls
        controls: {
            timeRange: '168',
            selectedModule: '',
            dataType: 'preprocessed'
        },
        
        // Historical Data Controls
        historicalControls: {
            timeRange: '168',
            selectedModule: '',
            dataType: 'preprocessed'
        },
        
        // Loading states
        analysisLoading: {
            timeSeries: false,
            distributions: false,
            correlation: false,
            temporal: false
        },
        
        // Charts
        predictionsChart: null,
        temperatureChart: null,
        humidityChart: null,
        pressureChart: null,
        
        // Methods
        async init() {
            try {
                this.isLoading = true;
                this.hasError = false;
                this.errorMessage = '';
                
                console.log('Starting dashboard initialization...');
                
                // Wait for Plotly to be available
                let retries = 0;
                while (typeof Plotly === 'undefined' && retries < 10) {
                    console.log('Waiting for Plotly to load...', retries);
                    await new Promise(resolve => setTimeout(resolve, 500));
                    retries++;
                }
                
                if (typeof Plotly === 'undefined') {
                    console.error('Plotly failed to load after retries');
                    this.chartsDisabled = true;
                } else {
                    console.log('Plotly loaded successfully');
                }
                
                // Wait for DOM to be ready
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Check if chart containers exist
                const predictionsContainer = document.getElementById('predictionsChart');
                const temperatureContainer = document.getElementById('temperatureChart');
                const humidityContainer = document.getElementById('humidityChart');
                const pressureContainer = document.getElementById('pressureChart');
                
                console.log('Chart containers found:', {
                    predictions: !!predictionsContainer,
                    temperature: !!temperatureContainer,
                    humidity: !!humidityContainer,
                    pressure: !!pressureContainer
                });
                
                // Set up charts first
                this.setupCharts();
                
                // Wait a bit for charts to be ready
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Then load data
                await this.loadInitialData();
                
                this.startAutoRefresh();
                this.isLoading = false;
                console.log('Dashboard initialization completed');
            } catch (error) {
                console.error('Error initializing dashboard:', error);
                this.isLoading = false;
                this.hasError = true;
                this.errorMessage = 'Failed to initialize dashboard. Please refresh the page.';
            }
        },
        
        async loadInitialData() {
            await Promise.all([
                this.loadSystemStatus(),
                this.loadCurrentWeather(),
                this.loadModelMetrics(),
                this.loadPredictions(),
                this.loadSensorData(),
                this.loadModules()
            ]);
            this.updateLastUpdateTime();
        },
        
        async loadSystemStatus() {
            try {
                const response = await fetch('/api/stats');
                const data = await response.json();
                
                // Check if source database is working
                // Consider it healthy if status is 'online' OR if we have sensor records (indicating successful connection)
                const sourceDbHealthy = data.raw_data?.status === 'online' || 
                                       (data.raw_data?.sensor_records !== undefined && data.raw_data?.sensor_records >= 0);
                
                this.systemStatus = {
                    sourceDb: sourceDbHealthy,
                    scheduler: data.is_running === true,
                    model: data.model_trained === true,
                    records: data.preprocessed_records || 0
                };
            } catch (error) {
                console.error('Error loading system status:', error);
                // If we can't even fetch stats, assume database is down
                this.systemStatus = {
                    sourceDb: false,
                    scheduler: false,
                    model: false,
                    records: 0
                };
            }
        },
        
        async loadCurrentWeather() {
            try {
                // Try preprocessed data first
                let response = await fetch('/api/preprocessed-data?hours_back=1&limit=1');
                let data = await response.json();
                
                if (data.length > 0) {
                    this.currentWeather = {
                        temperature: data[0].temperature,
                        humidity: data[0].humidity,
                        pressure: data[0].pressure,
                        module: 'preprocessed', // Preprocessed data doesn't have module info
                        timestamp: new Date(data[0].timestamp).toLocaleString()
                    };
                } else {
                    // Fallback to source data
                    response = await fetch('/api/sensor-data?hours=1&limit=1');
                    data = await response.json();
                    if (data.length > 0) {
                        this.currentWeather = {
                            temperature: data[0].temperature,
                            humidity: data[0].humidity,
                            pressure: data[0].pressure,
                            module: data[0].module,
                            timestamp: new Date(data[0].timestamp).toLocaleString()
                        };
                    }
                }
            } catch (error) {
                console.error('Error loading current weather:', error);
            }
        },
        
        async loadModelMetrics() {
            try {
                const response = await fetch('/api/model/benchmark');
                if (response.ok) {
                    const data = await response.json();
                    this.modelMetrics = {
                        mae: data.mae,
                        rmse: data.rmse,
                        r2: data.r2,
                        error: null
                    };
                } else {
                    const errorData = await response.json();
                    this.modelMetrics.error = errorData.error || 'No benchmark data available';
                }
            } catch (error) {
                this.modelMetrics.error = 'Error loading benchmark data';
            }
        },
        
        async loadPredictions() {
            try {
                // Use the time range for predictions as well, not just forecast hours
                const response = await fetch(`/api/predictions?hours=${this.controls.timeRange}`);
                if (!response.ok) {
                    console.warn('Failed to load predictions:', response.status);
                    this.recentPredictions = [];
                    return;
                }
                const data = await response.json();
                console.log('Predictions loaded:', data.length, 'records');
                
                // Sort data by timestamp to ensure chronological order
                const sortedData = Array.isArray(data) ? data.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)) : [];
                
                if (sortedData.length > 0) {
                    console.log('First prediction:', sortedData[0]);
                    console.log('Last prediction:', sortedData[sortedData.length - 1]);
                    console.log('Prediction time range:', new Date(sortedData[0].timestamp), 'to', new Date(sortedData[sortedData.length - 1].timestamp));
                }
                this.recentPredictions = sortedData;
                
                // Set last predicted temperature and time
                if (this.recentPredictions.length > 0) {
                    this.lastPredictedTemp = this.recentPredictions[0].predicted_temperature;
                    this.lastPredictedTempTime = this.recentPredictions[0].timestamp;
                } else {
                    this.lastPredictedTemp = null;
                    this.lastPredictedTempTime = null;
                }
                
                // Only update chart if we have data and chart is ready and not disabled
                if (this.recentPredictions.length > 0 && this.predictionsChart && !this.chartsDisabled) {
                    this.updatePredictionsChart();
                }
            } catch (error) {
                console.error('Error loading predictions:', error);
                this.recentPredictions = [];
            }
        },
        
        async loadSensorData() {
            try {
                console.log('Loading sensor data with controls:', this.historicalControls);
                
                const moduleParam = this.historicalControls.selectedModule ? `&module_id=${this.historicalControls.selectedModule}` : '';
                
                let response;
                let url;
                if (this.historicalControls.dataType === 'preprocessed') {
                    // Use preprocessed data endpoint
                    url = `/api/preprocessed-data?hours_back=${this.historicalControls.timeRange}${moduleParam}`;
                    response = await fetch(url);
                } else {
                    // Use source data endpoint
                    url = `/api/sensor-data?hours=${this.historicalControls.timeRange}${moduleParam}`;
                    response = await fetch(url);
                }
                
                console.log('Fetching sensor data from:', url);
                
                if (!response.ok) {
                    console.warn('Failed to load sensor data:', response.status);
                    this.sensorData = [];
                    return;
                }
                const data = await response.json();
                console.log('Sensor data loaded:', data.length, 'records');
                
                // Sort data by timestamp to ensure chronological order
                const sortedData = Array.isArray(data) ? data.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)) : [];
                
                if (sortedData.length > 0) {
                    console.log('First record:', sortedData[0]);
                    console.log('Last record:', sortedData[sortedData.length - 1]);
                    console.log('Time range:', new Date(sortedData[0].timestamp), 'to', new Date(sortedData[sortedData.length - 1].timestamp));
                }
                this.sensorData = sortedData;
                
                // Update individual charts if they're ready and not disabled
                if (this.sensorData.length > 0 && !this.chartsDisabled) {
                    console.log('Updating individual charts with', this.sensorData.length, 'data points');
                    if (this.temperatureChart) {
                        try {
                            this.updateTemperatureChart();
                        } catch (error) {
                            console.error('Failed to update temperature chart:', error);
                        }
                    }
                    if (this.humidityChart) {
                        try {
                            this.updateHumidityChart();
                        } catch (error) {
                            console.error('Failed to update humidity chart:', error);
                        }
                    }
                    if (this.pressureChart) {
                        try {
                            this.updatePressureChart();
                        } catch (error) {
                            console.error('Failed to update pressure chart:', error);
                        }
                    }
                } else {
                    console.log('Charts not updated - data length:', this.sensorData.length, 'charts disabled:', this.chartsDisabled);
                }
            } catch (error) {
                console.error('Error loading sensor data:', error);
                this.sensorData = [];
            }
        },
        
        async loadModules() {
            try {
                const response = await fetch('/api/modules');
                const data = await response.json();
                this.availableModules = data.modules || [];
            } catch (error) {
                console.error('Error loading modules:', error);
            }
        },
        
        setupCharts() {
            console.log('Setting up charts...');
            
            // Check if charts are disabled
            if (this.chartsDisabled) {
                console.log('Charts are disabled, skipping initialization');
                return;
            }
            
            // Check if Plotly is available
            if (typeof Plotly === 'undefined') {
                console.error('Plotly is not loaded');
                this.chartsDisabled = true;
                return;
            }
            
            console.log('Plotly is available, proceeding with chart setup');
            
            // Predictions Chart
            const predictionsCtx = document.getElementById('predictionsChart');
            if (!predictionsCtx) {
                console.error('Predictions chart canvas not found');
                this.chartsDisabled = true;
                return;
            }
            
            console.log('Predictions chart container found:', predictionsCtx);
            
            try {
                // Create initial empty chart with proper Plotly structure
                const predictionsData = [
                    {
                        x: [],
                        y: [],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Historical Temperature',
                        line: {
                            color: 'rgb(59, 130, 246)',
                            width: 2
                        },
                        marker: {
                            size: 4,
                            color: 'rgb(59, 130, 246)'
                        },
                        hovertemplate: '%{x}<br>Temperature: %{y:.1f}¬∞C<extra></extra>'
                    },
                    {
                        x: [],
                        y: [],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Predicted Temperature',
                        line: {
                            color: 'rgb(239, 68, 68)',
                            width: 2
                        },
                        marker: {
                            size: 4,
                            color: 'rgb(239, 68, 68)'
                        },
                        hovertemplate: '%{x}<br>Predicted: %{y:.1f}¬∞C<extra></extra>'
                    }
                ];
                
                const predictionsLayout = {
                    title: {
                        text: 'Temperature Predictions vs Historical Data',
                        font: { size: 16 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 12 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Temperature (¬∞C)',
                            font: { size: 12 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    legend: {
                        orientation: 'h',
                        y: 1.1,
                        x: 0.5,
                        xanchor: 'center',
                        bgcolor: 'rgba(255,255,255,0.8)'
                    },
                    height: 400,
                    margin: { t: 60, b: 60, l: 60, r: 40 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                const config = {
                    responsive: true,
                    displayModeBar: true,
                    modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                    displaylogo: false
                };
                
                console.log('Creating predictions chart with data:', predictionsData);
                console.log('Layout:', predictionsLayout);
                
                Plotly.newPlot(predictionsCtx, predictionsData, predictionsLayout, config);
                this.predictionsChart = predictionsCtx;
                console.log('Predictions chart initialized successfully');
                
                // Test if the chart is actually rendered
                setTimeout(() => {
                    const chartElement = predictionsCtx.querySelector('.plotly');
                    if (chartElement) {
                        console.log('Chart element found and rendered:', chartElement);
                    } else {
                        console.warn('Chart element not found after initialization');
                    }
                }, 1000);
            } catch (error) {
                console.error('Error creating predictions chart:', error);
                this.predictionsChart = null;
                this.chartsDisabled = true;
                this.disablePredictionsChart();
            }
            
            // Temperature Chart
            const temperatureCtx = document.getElementById('temperatureChart');
            if (!temperatureCtx) {
                console.error('Temperature chart canvas not found');
                return;
            }
            
            console.log('Temperature chart container found:', temperatureCtx);
            
            try {
                const temperatureData = [
                    {
                        x: [],
                        y: [],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Temperature',
                        line: {
                            color: 'rgb(239, 68, 68)',
                            width: 2
                        },
                        marker: {
                            size: 3,
                            color: 'rgb(239, 68, 68)'
                        },
                        hovertemplate: '%{x}<br>Temperature: %{y:.1f}¬∞C<extra></extra>'
                    }
                ];
                
                const temperatureLayout = {
                    title: {
                        text: 'Temperature Over Time',
                        font: { size: 14 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 10 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Temperature (¬∞C)',
                            font: { size: 10 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    height: 300,
                    margin: { t: 40, b: 40, l: 50, r: 20 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                console.log('Creating temperature chart with data:', temperatureData);
                console.log('Temperature layout:', temperatureLayout);
                
                Plotly.newPlot(temperatureCtx, temperatureData, temperatureLayout, config);
                this.temperatureChart = temperatureCtx;
                console.log('Temperature chart initialized successfully');
                
                // Test if the chart is actually rendered
                setTimeout(() => {
                    const chartElement = temperatureCtx.querySelector('.plotly');
                    if (chartElement) {
                        console.log('Temperature chart element found and rendered:', chartElement);
                    } else {
                        console.warn('Temperature chart element not found after initialization');
                    }
                }, 1000);
            } catch (error) {
                console.error('Error creating temperature chart:', error);
                this.temperatureChart = null;
            }
            
            // Humidity Chart
            const humidityCtx = document.getElementById('humidityChart');
            if (!humidityCtx) {
                console.error('Humidity chart canvas not found');
                return;
            }
            
            console.log('Humidity chart container found:', humidityCtx);
            
            try {
                const humidityData = [
                    {
                        x: [],
                        y: [],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Humidity',
                        line: {
                            color: 'rgb(59, 130, 246)',
                            width: 2
                        },
                        marker: {
                            size: 3,
                            color: 'rgb(59, 130, 246)'
                        },
                        hovertemplate: '%{x}<br>Humidity: %{y:.1f}%<extra></extra>'
                    }
                ];
                
                const humidityLayout = {
                    title: {
                        text: 'Humidity Over Time',
                        font: { size: 14 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 10 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Humidity (%)',
                            font: { size: 10 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    height: 300,
                    margin: { t: 40, b: 40, l: 50, r: 20 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                Plotly.newPlot(humidityCtx, humidityData, humidityLayout, config);
                this.humidityChart = humidityCtx;
                console.log('Humidity chart initialized successfully');
            } catch (error) {
                console.error('Error creating humidity chart:', error);
                this.humidityChart = null;
            }
            
            // Pressure Chart
            const pressureCtx = document.getElementById('pressureChart');
            if (!pressureCtx) {
                console.error('Pressure chart canvas not found');
                return;
            }
            
            console.log('Pressure chart container found:', pressureCtx);
            
            try {
                const pressureData = [
                    {
                        x: [],
                        y: [],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Pressure',
                        line: {
                            color: 'rgb(34, 197, 94)',
                            width: 2
                        },
                        marker: {
                            size: 3,
                            color: 'rgb(34, 197, 94)'
                        },
                        hovertemplate: '%{x}<br>Pressure: %{y:.1f}hPa<extra></extra>'
                    }
                ];
                
                const pressureLayout = {
                    title: {
                        text: 'Pressure Over Time',
                        font: { size: 14 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 10 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Pressure (hPa)',
                            font: { size: 10 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    height: 300,
                    margin: { t: 40, b: 40, l: 50, r: 20 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                Plotly.newPlot(pressureCtx, pressureData, pressureLayout, config);
                this.pressureChart = pressureCtx;
                console.log('Pressure chart initialized successfully');
            } catch (error) {
                console.error('Error creating pressure chart:', error);
                this.pressureChart = null;
            }
        },
        
        updatePredictionsChart() {
            if (this.chartsDisabled || !this.predictionsChart) {
                console.warn('Predictions chart not available or disabled');
                return;
            }
            
            try {
                // Use all available data instead of limiting to 50 points
                const historicalData = this.sensorData && this.sensorData.length > 0 ? this.sensorData : [];
                const predictionData = this.recentPredictions && this.recentPredictions.length > 0 ? this.recentPredictions : [];
                
                console.log('Historical data for chart:', historicalData.length, 'points');
                console.log('Prediction data for chart:', predictionData.length, 'points');
                console.log('Sample historical data:', historicalData.slice(0, 3));
                console.log('Sample prediction data:', predictionData.slice(0, 3));
                
                // Create data arrays for Plotly with proper timestamp handling
                const historicalX = historicalData.map(d => new Date(d.timestamp));
                const historicalY = historicalData.map(d => Number(d.temperature) || 0);
                
                const predictionX = predictionData.map(d => new Date(d.timestamp));
                const predictionY = predictionData.map(d => Number(d.predicted_temperature) || 0);
                
                console.log('Historical X range:', historicalX.length > 0 ? `${historicalX[0]} to ${historicalX[historicalX.length-1]}` : 'empty');
                console.log('Prediction X range:', predictionX.length > 0 ? `${predictionX[0]} to ${predictionX[predictionX.length-1]}` : 'empty');
                
                // If we have no data at all, don't update the chart
                if (historicalX.length === 0 && predictionX.length === 0) {
                    console.warn('No data available for predictions chart');
                    return;
                }
                
                // Always use replot for better timestamp handling and to ensure proper updates
                this.replotPredictionsChart(historicalX, historicalY, predictionX, predictionY);
                
            } catch (error) {
                console.error('Error updating predictions chart:', error);
                // Disable the chart if it keeps failing
                this.disablePredictionsChart();
            }
        },
        
        replotPredictionsChart(historicalX, historicalY, predictionX, predictionY) {
            try {
                const plotData = [
                    {
                        x: historicalX,
                        y: historicalY,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Historical Temperature',
                        line: {
                            color: 'rgb(59, 130, 246)',
                            width: 2
                        },
                        marker: {
                            size: 4,
                            color: 'rgb(59, 130, 246)'
                        },
                        hovertemplate: '%{x}<br>Temperature: %{y:.1f}¬∞C<extra></extra>'
                    },
                    {
                        x: predictionX,
                        y: predictionY,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Predicted Temperature',
                        line: {
                            color: 'rgb(239, 68, 68)',
                            width: 2
                        },
                        marker: {
                            size: 4,
                            color: 'rgb(239, 68, 68)'
                        },
                        hovertemplate: '%{x}<br>Predicted: %{y:.1f}¬∞C<extra></extra>'
                    }
                ];
                
                const layout = {
                    title: {
                        text: 'Temperature Predictions vs Historical Data',
                        font: { size: 16 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 12 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Temperature (¬∞C)',
                            font: { size: 12 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    legend: {
                        orientation: 'h',
                        y: 1.1,
                        x: 0.5,
                        xanchor: 'center',
                        bgcolor: 'rgba(255,255,255,0.8)'
                    },
                    height: 400,
                    margin: { t: 60, b: 60, l: 60, r: 40 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                const config = {
                    responsive: true,
                    displayModeBar: true,
                    modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                    displaylogo: false
                };
                
                Plotly.newPlot(this.predictionsChart, plotData, layout, config);
                console.log('Predictions chart replotted successfully');
            } catch (error) {
                console.error('Error replotting predictions chart:', error);
                this.disablePredictionsChart();
            }
        },
        
        updateTemperatureChart() {
            console.log('updateTemperatureChart called');
            
            if (this.chartsDisabled || !this.temperatureChart) {
                console.warn('Temperature chart not available or disabled - charts disabled:', this.chartsDisabled, 'chart exists:', !!this.temperatureChart);
                return;
            }
            
            try {
                if (!this.sensorData || this.sensorData.length === 0) {
                    console.warn('No sensor data available for temperature chart');
                    return;
                }
                
                console.log('Sensor data for temperature chart:', this.sensorData.length, 'points');
                
                // Create data arrays for Plotly with proper timestamp handling
                const x = this.sensorData.map(d => new Date(d.timestamp));
                const temperatureValues = this.sensorData.map(d => Number(d.temperature) || 0);
                
                console.log('Temperature X range:', x.length > 0 ? `${x[0]} to ${x[x.length-1]}` : 'empty');
                console.log('Temperature Y range:', temperatureValues.length > 0 ? `${Math.min(...temperatureValues)} to ${Math.max(...temperatureValues)}` : 'empty');
                
                // Always use replot for better timestamp handling and to ensure proper updates
                this.replotTemperatureChart(x, temperatureValues);
                
            } catch (error) {
                console.error('Error updating temperature chart:', error);
                this.disableTemperatureChart();
            }
        },
        
        replotTemperatureChart(x, temperatureValues) {
            try {
                console.log('replotTemperatureChart called with', x.length, 'data points');
                
                const plotData = [
                    {
                        x: x,
                        y: temperatureValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Temperature',
                        line: {
                            color: 'rgb(239, 68, 68)',
                            width: 2
                        },
                        marker: {
                            size: 3,
                            color: 'rgb(239, 68, 68)'
                        },
                        hovertemplate: '%{x}<br>Temperature: %{y:.1f}¬∞C<extra></extra>'
                    }
                ];
                
                const layout = {
                    title: {
                        text: 'Temperature Over Time',
                        font: { size: 14 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 10 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Temperature (¬∞C)',
                            font: { size: 10 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    height: 300,
                    margin: { t: 40, b: 40, l: 50, r: 20 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                const config = {
                    responsive: true,
                    displayModeBar: true,
                    modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                    displaylogo: false
                };
                
                console.log('Replotting temperature chart with data:', plotData);
                console.log('Temperature chart element:', this.temperatureChart);
                
                Plotly.newPlot(this.temperatureChart, plotData, layout, config);
                console.log('Temperature chart replotted successfully');
                
                // Test if the chart is actually rendered
                setTimeout(() => {
                    const chartElement = this.temperatureChart.querySelector('.plotly');
                    if (chartElement) {
                        console.log('Temperature chart element found and rendered after replot:', chartElement);
                    } else {
                        console.warn('Temperature chart element not found after replot');
                    }
                }, 1000);
            } catch (error) {
                console.error('Error replotting temperature chart:', error);
                this.disableTemperatureChart();
            }
        },
        
        updateHumidityChart() {
            if (this.chartsDisabled || !this.humidityChart) {
                console.warn('Humidity chart not available or disabled');
                return;
            }
            
            try {
                if (!this.sensorData || this.sensorData.length === 0) {
                    console.warn('No sensor data available for humidity chart');
                    return;
                }
                
                console.log('Sensor data for humidity chart:', this.sensorData.length, 'points');
                
                // Create data arrays for Plotly with proper timestamp handling
                const x = this.sensorData.map(d => new Date(d.timestamp));
                const humidityValues = this.sensorData.map(d => Number(d.humidity) || 0);
                
                console.log('Humidity X range:', x.length > 0 ? `${x[0]} to ${x[x.length-1]}` : 'empty');
                
                // Always use replot for better timestamp handling and to ensure proper updates
                this.replotHumidityChart(x, humidityValues);
                
            } catch (error) {
                console.error('Error updating humidity chart:', error);
                this.disableHumidityChart();
            }
        },
        
        replotHumidityChart(x, humidityValues) {
            try {
                const plotData = [
                    {
                        x: x,
                        y: humidityValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Humidity',
                        line: {
                            color: 'rgb(59, 130, 246)',
                            width: 2
                        },
                        marker: {
                            size: 3,
                            color: 'rgb(59, 130, 246)'
                        },
                        hovertemplate: '%{x}<br>Humidity: %{y:.1f}%<extra></extra>'
                    }
                ];
                
                const layout = {
                    title: {
                        text: 'Humidity Over Time',
                        font: { size: 14 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 10 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Humidity (%)',
                            font: { size: 10 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    height: 300,
                    margin: { t: 40, b: 40, l: 50, r: 20 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                const config = {
                    responsive: true,
                    displayModeBar: true,
                    modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                    displaylogo: false
                };
                
                Plotly.newPlot(this.humidityChart, plotData, layout, config);
                console.log('Humidity chart replotted successfully');
            } catch (error) {
                console.error('Error replotting humidity chart:', error);
                this.disableHumidityChart();
            }
        },
        
        updatePressureChart() {
            if (this.chartsDisabled || !this.pressureChart) {
                console.warn('Pressure chart not available or disabled');
                return;
            }
            
            try {
                if (!this.sensorData || this.sensorData.length === 0) {
                    console.warn('No sensor data available for pressure chart');
                    return;
                }
                
                console.log('Sensor data for pressure chart:', this.sensorData.length, 'points');
                
                // Create data arrays for Plotly with proper timestamp handling
                const x = this.sensorData.map(d => new Date(d.timestamp));
                const pressureValues = this.sensorData.map(d => Number(d.pressure) || 0);
                
                console.log('Pressure X range:', x.length > 0 ? `${x[0]} to ${x[x.length-1]}` : 'empty');
                
                // Always use replot for better timestamp handling and to ensure proper updates
                this.replotPressureChart(x, pressureValues);
                
            } catch (error) {
                console.error('Error updating pressure chart:', error);
                this.disablePressureChart();
            }
        },
        
        replotPressureChart(x, pressureValues) {
            try {
                const plotData = [
                    {
                        x: x,
                        y: pressureValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Pressure',
                        line: {
                            color: 'rgb(34, 197, 94)',
                            width: 2
                        },
                        marker: {
                            size: 3,
                            color: 'rgb(34, 197, 94)'
                        },
                        hovertemplate: '%{x}<br>Pressure: %{y:.1f}hPa<extra></extra>'
                    }
                ];
                
                const layout = {
                    title: {
                        text: 'Pressure Over Time',
                        font: { size: 14 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 10 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Pressure (hPa)',
                            font: { size: 10 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    height: 300,
                    margin: { t: 40, b: 40, l: 50, r: 20 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                const config = {
                    responsive: true,
                    displayModeBar: true,
                    modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                    displaylogo: false
                };
                
                Plotly.newPlot(this.pressureChart, plotData, layout, config);
                console.log('Pressure chart replotted successfully');
            } catch (error) {
                console.error('Error replotting pressure chart:', error);
                this.disablePressureChart();
            }
        },
        
        disablePredictionsChart() {
            console.warn('Disabling predictions chart due to errors');
            if (this.predictionsChart) {
                try {
                    Plotly.purge(this.predictionsChart);
                } catch (e) {
                    console.error('Error purging predictions chart:', e);
                }
                this.predictionsChart = null;
            }
            // Hide the chart container
            const container = document.querySelector('.chart-container');
            if (container) {
                container.innerHTML = '<div class="text-center py-8 text-gray-500">Predictions chart temporarily disabled due to data issues</div>';
            }
        },
        
        disableTemperatureChart() {
            console.warn('Disabling temperature chart due to errors');
            if (this.temperatureChart) {
                try {
                    Plotly.purge(this.temperatureChart);
                } catch (e) {
                    console.error('Error purging temperature chart:', e);
                }
                this.temperatureChart = null;
            }
        },
        
        disableHumidityChart() {
            console.warn('Disabling humidity chart due to errors');
            if (this.humidityChart) {
                try {
                    Plotly.purge(this.humidityChart);
                } catch (e) {
                    console.error('Error purging humidity chart:', e);
                }
                this.humidityChart = null;
            }
        },
        
        disablePressureChart() {
            console.warn('Disabling pressure chart due to errors');
            if (this.pressureChart) {
                try {
                    Plotly.purge(this.pressureChart);
                } catch (e) {
                    console.error('Error purging pressure chart:', e);
                }
                this.pressureChart = null;
            }
        },
        
        async updateData() {
            await this.loadSensorData();
            await this.loadPredictions(); // Also load predictions for the time range
            await this.loadCurrentWeather();
            
            // Update individual charts if they're ready and not disabled
            if (this.sensorData.length > 0 && !this.chartsDisabled) {
                if (this.temperatureChart) {
                    try {
                        this.updateTemperatureChart();
                    } catch (error) {
                        console.error('Failed to update temperature chart:', error);
                    }
                }
                if (this.humidityChart) {
                    try {
                        this.updateHumidityChart();
                    } catch (error) {
                        console.error('Failed to update humidity chart:', error);
                    }
                }
                if (this.pressureChart) {
                    try {
                        this.updatePressureChart();
                    } catch (error) {
                        console.error('Failed to update pressure chart:', error);
                    }
                }
            }
            
            // Update predictions chart if ready and not disabled
            if (this.predictionsChart && this.recentPredictions.length > 0 && !this.chartsDisabled) {
                try {
                    this.updatePredictionsChart();
                } catch (error) {
                    console.error('Failed to update predictions chart:', error);
                }
            }
        },
        
        async updateHistoricalData() {
            await this.loadSensorData();
            if (this.temperatureChart && this.sensorData.length > 0 && !this.chartsDisabled) {
                try {
                    this.updateTemperatureChart();
                } catch (error) {
                    console.error('Failed to update temperature chart:', error);
                }
            }
            if (this.humidityChart && this.sensorData.length > 0 && !this.chartsDisabled) {
                try {
                    this.updateHumidityChart();
                } catch (error) {
                    console.error('Failed to update humidity chart:', error);
                }
            }
            if (this.pressureChart && this.sensorData.length > 0 && !this.chartsDisabled) {
                try {
                    this.updatePressureChart();
                } catch (error) {
                    console.error('Failed to update pressure chart:', error);
                }
            }
        },

        async refreshHistoricalData() {
            await this.updateHistoricalData();
        },
        
        async updatePredictions() {
            // Load predictions for the selected time range
            await this.loadPredictions();
            
            // Update predictions chart if ready and not disabled
            if (this.predictionsChart && this.recentPredictions.length > 0 && !this.chartsDisabled) {
                try {
                    this.updatePredictionsChart();
                } catch (error) {
                    console.error('Failed to update predictions chart:', error);
                }
            }
        },
        
        async refreshAnalysis() {
            this.analysisLoading = {
                timeSeries: true,
                distributions: true,
                correlation: true,
                temporal: true
            };
            
            const timestamp = new Date().getTime();
            const plots = ['time-series-plot', 'distribution-plot', 'correlation-plot', 'temporal-plot'];
            
            for (const plotId of plots) {
                const img = document.getElementById(plotId);
                if (img) {
                    img.src = img.src.split('?')[0] + '?t=' + timestamp;
                    img.onload = () => {
                        this.analysisLoading[plotId.replace('-plot', '')] = false;
                    };
                    img.onerror = () => {
                        this.analysisLoading[plotId.replace('-plot', '')] = false;
                    };
                }
            }
        },
        
        async refreshBenchmark() {
            await this.loadModelMetrics();
        },
        
        async refreshAllData() {
            await this.loadInitialData();
        },
        
        toggleAutoRefresh() {
            this.autoRefreshEnabled = !this.autoRefreshEnabled;
            if (this.autoRefreshEnabled) {
                this.startAutoRefresh();
            } else {
                this.stopAutoRefresh();
            }
        },
        
        startAutoRefresh() {
            if (this.autoRefreshInterval) {
                clearInterval(this.autoRefreshInterval);
            }
            this.autoRefreshInterval = setInterval(() => {
                this.loadPredictions();
                this.loadCurrentWeather();
                this.updateLastUpdateTime();
            }, 10000); // 10 seconds
        },
        
        stopAutoRefresh() {
            if (this.autoRefreshInterval) {
                clearInterval(this.autoRefreshInterval);
                this.autoRefreshInterval = null;
            }
        },
        
        updateLastUpdateTime() {
            this.lastUpdateTime = new Date().toLocaleTimeString();
        },
        
        formatDateTime(timestamp) {
            return new Date(timestamp).toLocaleString();
        },
        
        getConfidenceClass(confidence) {
            if (confidence >= 0.8) return 'confidence-high';
            if (confidence >= 0.6) return 'confidence-medium';
            return 'confidence-low';
        },

        getStatusClass(status) {
            if (status) {
                return 'status-green';
            } else {
                return 'status-red';
            }
        }
    }
}
</script>
{% endblock %} 