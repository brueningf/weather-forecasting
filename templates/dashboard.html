{% extends 'base.html' %}
{% block title %}Weather Forecasting{% endblock %}
{% block head %}
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <link rel="stylesheet" href="/static/dashboard.css">
    
    {# Logger Configuration #}
    <div id="logger-config" 
         data-enabled="{{ config.LOGGING_ENABLED | lower }}"
         data-level="{{ config.LOG_LEVEL }}"
         data-verbose="{{ config.LOG_VERBOSE | lower }}"
         style="display: none;"></div>
    <script>
        // Load logger config from data attributes
        const configElement = document.getElementById('logger-config');
        window.LoggerConfig = {
            enabled: configElement.dataset.enabled === 'true',
            level: configElement.dataset.level,
            verbose: configElement.dataset.verbose === 'true'
        };
    </script>
    
    {# Include Logger Component #}
    {% include 'components/logger.html' with context %}
{% endblock %}
{% block content %}
<div x-data="dashboardApp()" class="min-h-screen bg-gray-50">
    <!-- Loading State -->
    <div x-show="isLoading" class="fixed inset-0 bg-white bg-opacity-90 flex items-center justify-center z-50">
        <div class="text-center">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
            <p class="text-gray-600">Loading Weather Dashboard...</p>
        </div>
    </div>

    <!-- Error State -->
    <div x-show="hasError" class="fixed inset-0 bg-white bg-opacity-90 flex items-center justify-center z-50">
        <div class="text-center max-w-md mx-auto p-6">
            <div class="text-red-500 text-6xl mb-4">‚ö†Ô∏è</div>
            <h2 class="text-xl font-semibold text-gray-900 mb-2">Dashboard Error</h2>
            <p class="text-gray-600 mb-4" x-text="errorMessage"></p>
            <button @click="init()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg">
                Retry
            </button>
        </div>
    </div>

    <!-- Header Section -->
    <div class="bg-white shadow-sm border-b">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center py-6">
                <div class="flex items-center">
                    <div class="text-3xl mr-3">üå¶Ô∏è</div>
                    <div>
                        <h1 class="text-2xl font-bold text-gray-900">Weather Forecasting Dashboard</h1>
                        <p class="text-sm text-gray-500">Real-time monitoring & predictive analytics</p>
                    </div>
                </div>
                <div class="flex items-center space-x-4">
                    <div class="text-sm text-gray-500">
                        Last updated: <span x-text="lastUpdateTime"></span>
                    </div>
                    <button @click="refreshAllData()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg flex items-center space-x-2 transition-colors">
                        <span class="refresh-button">üîÑ</span>
                        <span>Refresh All</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <!-- Real-Time Weather Monitoring -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
            <!-- Current Conditions -->
            {% include 'components/current_conditions.html' with context %}

            <!-- Model Performance -->
            <div class="bg-white rounded-xl p-6 card-hover shadow-sm">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-semibold text-gray-900">üìà Model Performance</h2>
                    <button @click="refreshBenchmark()" class="text-blue-600 hover:text-blue-800 text-sm">üîÑ Refresh</button>
                </div>
                
                <div class="grid grid-cols-3 gap-4">
                    <div class="text-center">
                        <div class="text-2xl font-bold text-blue-700" x-text="modelMetrics.mae ? modelMetrics.mae.toFixed(3) : '--'"></div>
                        <div class="text-sm text-gray-600">MAE</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-blue-700" x-text="modelMetrics.rmse ? modelMetrics.rmse.toFixed(3) : '--'"></div>
                        <div class="text-sm text-gray-600">RMSE</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-blue-700" x-text="modelMetrics.r2 ? modelMetrics.r2.toFixed(3) : '--'"></div>
                        <div class="text-sm text-gray-600">R¬≤</div>
                    </div>
                </div>
                
                <div x-show="modelMetrics.error" class="mt-4 p-3 bg-red-50 border border-red-200 rounded-lg">
                    <div class="text-sm text-red-600" x-text="modelMetrics.error"></div>
                </div>
            </div>
        </div>

        <!-- Controls Section -->
        <div class="bg-white rounded-xl p-6 mb-8 shadow-sm">
            <h2 class="text-lg font-semibold text-gray-900 mb-4">üìã Controls & Filters</h2>
            
            <!-- Data Quality Indicator -->
            <div x-show="controls.dataType === 'source' && sensorData.length > 0" class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-lg">
                <div class="flex items-center">
                    <span class="text-blue-600 mr-2">‚ÑπÔ∏è</span>
                    <div class="text-sm text-blue-800">
                        <div class="font-medium">Raw Source Data Info:</div>
                        <div x-show="sensorData.length > 0">
                            <span x-text="getRawSourceDataQualityText()"></span>
                            <span x-show="controls.selectedModule" x-text="` from module ${controls.selectedModule}`"></span>
                            <span x-show="!controls.selectedModule" x-text="` from all modules`"></span>
                        </div>
                        <div x-show="getRawSourceDataQuality() && getRawSourceDataQuality().quality === 'poor'" class="text-xs text-orange-600 mt-1">
                            ‚ö†Ô∏è Data distribution may be uneven - consider selecting a specific module or using preprocessed data
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Time Range</label>
                    <select x-model="controls.timeRange" @change="updateData()" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <template x-for="option in timeRangeOptions" :key="option.value">
                            <option :value="option.value" x-text="option.label"></option>
                        </template>
                    </select>
                </div>
                
                <div x-show="controls.dataType === 'source'">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Module</label>
                    <select x-model="controls.selectedModule" @change="updateData()" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="">All Modules</option>
                        <template x-for="module in availableModules" :key="module">
                            <option :value="module" x-text="module"></option>
                        </template>
                    </select>
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Data Type</label>
                    <select x-model="controls.dataType" @change="updateData()" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="preprocessed">Preprocessed</option>
                        <option value="source">Raw Source</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Predictive Analytics Dashboard -->
        <div class="bg-white rounded-xl p-6 mb-8 card-hover shadow-sm">
            <div class="flex items-center justify-between mb-6">
                <h2 class="text-xl font-semibold text-gray-900">üîÆ Predictive Analytics</h2>
                <div class="flex items-center space-x-4">
                    <div class="text-sm text-gray-500">
                        Auto-refresh: <span x-text="autoRefreshEnabled ? 'ON' : 'OFF'"></span>
                    </div>
                    <button @click="toggleAutoRefresh()" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm">
                        <span x-text="autoRefreshEnabled ? 'Disable' : 'Enable'"></span>
                    </button>
                </div>
            </div>
            
            <div class="chart-container">
                <div id="predictionsChart"></div>
                <div x-show="chartsDisabled" class="text-center py-8 text-gray-500">
                    <div class="text-2xl mb-2">üìä</div>
                    <p>Predictions chart temporarily disabled</p>
                    <p class="text-sm">Data is still being collected and displayed in the table below</p>
                </div>
            </div>
            
            <!-- Recent Predictions Table -->
            <div class="mt-6">
                <h3 class="text-lg font-semibold text-gray-900 mb-3">Recent Predictions</h3>
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Timestamp</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Predicted Temp</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Confidence</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
                            <template x-for="prediction in recentPredictions.slice(0, 5)" :key="prediction.timestamp">
                                <tr>
                                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900" x-text="formatDateTime(prediction.timestamp)"></td>
                                    <td class="px-6 py-4 whitespace-nowrap text-sm font-semibold text-gray-900" x-text="prediction.predicted_temperature.toFixed(1) + '¬∞C'"></td>
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <span class="prediction-confidence" :class="getConfidenceClass(prediction.confidence)" x-text="(prediction.confidence * 100).toFixed(1) + '%'"></span>
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <span class="status-dot status-green"></span>
                                        <span class="text-sm text-gray-900">Active</span>
                                    </td>
                                </tr>
                            </template>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Advanced Data Analysis Suite -->
        <div class="bg-white rounded-xl p-6 mb-8 card-hover shadow-sm">
            <div class="flex items-center justify-between mb-6">
                <h2 class="text-xl font-semibold text-gray-900">üìä Advanced Data Analysis</h2>
                <button @click="refreshAnalysis()" class="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg card-hover">
                    üîÑ Refresh Analysis
                </button>
            </div>
            
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <template x-for="plot in analysisPlots" :key="plot.id">
                    <div>
                        <h3 class="text-lg font-semibold text-gray-700 mb-3" x-text="plot.title"></h3>
                        <div class="relative">
                            <img :id="plot.id" :src="plot.src" :alt="plot.title" class="w-full rounded-lg shadow-sm">
                            <div x-show="analysisLoading[plot.key]" class="absolute inset-0 bg-gray-200 loading-skeleton rounded-lg"></div>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- Historical Data Visualization -->
        <div class="bg-white rounded-xl p-6 mb-8 card-hover shadow-sm">
            <h2 class="text-xl font-semibold text-gray-900 mb-6">üìà Historical Data Visualization</h2>
            
            <!-- Historical Data Controls -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Historical Time Range</label>
                    <select x-model="historicalControls.timeRange" @change="loadSensorData('historical')" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <template x-for="option in timeRangeOptions" :key="option.value">
                            <option :value="option.value" x-text="option.label"></option>
                        </template>
                    </select>
                </div>
                
                <div x-show="historicalControls.dataType === 'source'">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Module</label>
                    <select x-model="historicalControls.selectedModule" @change="loadSensorData('historical')" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="">All Modules</option>
                        <template x-for="module in availableModules" :key="module">
                            <option :value="module" x-text="module"></option>
                        </template>
                    </select>
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Historical Data Type</label>
                    <select x-model="historicalControls.dataType" @change="loadSensorData('historical')" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="preprocessed">Preprocessed</option>
                        <option value="source">Raw Source</option>
                    </select>
                </div>
                
                <div class="flex items-end">
                    <button @click="loadSensorData('historical')" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition-colors">
                        üîÑ Refresh Historical
                    </button>
                </div>
            </div>
            
            <!-- Historical Data Quality Indicator -->
            <div x-show="historicalControls.dataType === 'source' && sensorData.length > 0" class="mb-6 p-3 bg-blue-50 border border-blue-200 rounded-lg">
                <div class="flex items-center">
                    <span class="text-blue-600 mr-2">‚ÑπÔ∏è</span>
                    <div class="text-sm text-blue-800">
                        <div class="font-medium">Historical Raw Source Data Info:</div>
                        <div x-show="sensorData.length > 0">
                            <span x-text="getHistoricalDataQualityText()"></span>
                            <span x-show="historicalControls.selectedModule" x-text="` from module ${historicalControls.selectedModule}`"></span>
                            <span x-show="!historicalControls.selectedModule" x-text="` from all modules`"></span>
                        </div>
                        <div x-show="getHistoricalDataQuality() && getHistoricalDataQuality().quality === 'poor'" class="text-xs text-orange-600 mt-1">
                            ‚ö†Ô∏è Data distribution may be uneven - consider selecting a specific module or using preprocessed data
                        </div>
                    </div>
                </div>
            </div>

            <!-- Individual Historical Charts -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <template x-for="chart in historicalCharts" :key="chart.id">
                    <div class="bg-gray-50 rounded-lg p-4">
                        <h3 class="text-lg font-semibold text-gray-900 mb-3" x-text="chart.title"></h3>
                        <div class="chart-container" style="height: 300px;">
                            <div :id="chart.id"></div>
                            <div x-show="chartsDisabled" class="text-center py-8 text-gray-500">
                                <div class="text-2xl mb-2" x-text="chart.icon"></div>
                                <p x-text="chart.name + ' chart temporarily disabled'"></p>
                            </div>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- System Status Overview -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
            <template x-for="status in systemStatusItems" :key="status.key">
                <div class="bg-white rounded-xl p-6 card-hover shadow-sm">
                    <div class="flex items-center justify-between">
                        <div>
                            <p class="text-sm font-medium text-gray-600" x-text="status.label"></p>
                            <div class="flex items-center mt-2" x-show="status.type === 'status'">
                                <span class="status-dot" :class="getStatusClass(systemStatus[status.key])"></span>
                                <span class="text-sm font-semibold" x-text="systemStatus[status.key] ? status.trueText : status.falseText"></span>
                            </div>
                            <div class="mt-2" x-show="status.type === 'count'">
                                <span class="text-lg font-bold text-gray-900" x-text="systemStatus[status.key] || 0"></span>
                            </div>
                        </div>
                        <div class="text-2xl" x-text="status.icon"></div>
                    </div>
                </div>
            </template>
        </div>
    </div>
</div>

<script>
function dashboardApp() {
    return {
        // State
        lastUpdateTime: '--',
        autoRefreshEnabled: false,
        autoRefreshInterval: null,
        isLoading: true,
        hasError: false,
        errorMessage: '',
        chartsDisabled: false, // New flag to disable charts if they cause issues
        
        // Data
        currentWeather: {},
        currentWeatherLoading: false,
        currentWeatherError: null,
        systemStatus: {
            sourceDb: false,
            scheduler: false,
            model: false,
            records: 0
        },
        modelMetrics: {
            mae: null,
            rmse: null,
            r2: null,
            error: null
        },
        recentPredictions: [],
        availableModules: [],
        sensorData: [],
        lastPredictedTemp: null,
        lastPredictedTempTime: null,
        
        // Controls
        controls: {
            timeRange: '48',  // Changed from '6' to '48'
            selectedModule: '',
            dataType: 'preprocessed'
        },
        
        // Historical Data Controls
        historicalControls: {
            timeRange: '48',  // Changed from '6' to '48'
            selectedModule: '',
            dataType: 'preprocessed'
        },
        
        // Loading states
        analysisLoading: {
            timeSeries: false,
            distributions: false,
            correlation: false,
            temporal: false
        },
        
        // Charts
        predictionsChart: null,
        temperatureChart: null,
        humidityChart: null,
        pressureChart: null,
        
        // Data structures for templates
        timeRangeOptions: [
            { value: '6', label: 'Last 6 hours' },
            { value: '12', label: 'Last 12 hours' },
            { value: '24', label: 'Last 24 hours' },
            { value: '48', label: 'Last 48 hours' },
            { value: '168', label: 'Last week' },
            { value: '720', label: 'Last month' }
        ],
        
        systemStatusItems: [
            { key: 'sourceDb', label: 'Database Status', type: 'status', trueText: 'Healthy', falseText: 'Error', icon: 'üóÑÔ∏è' },
            { key: 'scheduler', label: 'Scheduler Status', type: 'status', trueText: 'Running', falseText: 'Stopped', icon: '‚è∞' },
            { key: 'model', label: 'Model Status', type: 'status', trueText: 'Trained', falseText: 'Not Ready', icon: 'ü§ñ' },
            { key: 'records', label: 'Data Records', type: 'count', icon: 'üìä' }
        ],
        
        historicalCharts: [
            { id: 'temperatureChart', name: 'Temperature', title: 'üå°Ô∏è Temperature', icon: 'üå°Ô∏è', field: 'temperature', color: 'rgb(239, 68, 68)', unit: '¬∞C' },
            { id: 'humidityChart', name: 'Humidity', title: 'üíß Humidity', icon: 'üíß', field: 'humidity', color: 'rgb(59, 130, 246)', unit: '%' },
            { id: 'pressureChart', name: 'Pressure', title: 'üå™Ô∏è Pressure', icon: 'üå™Ô∏è', field: 'pressure', color: 'rgb(34, 197, 94)', unit: 'hPa' }
        ],
        
        analysisPlots: [
            { id: 'time-series-plot', key: 'timeSeries', title: 'Time Series Analysis', src: '/api/analysis/time-series' },
            { id: 'distribution-plot', key: 'distributions', title: 'Data Distributions', src: '/api/analysis/distributions' },
            { id: 'correlation-plot', key: 'correlation', title: 'Correlation Matrix', src: '/api/analysis/correlation' },
            { id: 'temporal-plot', key: 'temporal', title: 'Temporal Patterns', src: '/api/analysis/temporal' }
        ],
        
        // Methods
        async init() {
            // Set up watchers to sync controls
            this.$watch('controls.timeRange', (value) => {
                this.historicalControls.timeRange = value;
            });
            
            this.$watch('controls.dataType', (value) => {
                this.historicalControls.dataType = value;
            });
            
            this.$watch('controls.selectedModule', (value) => {
                this.historicalControls.selectedModule = value;
            });
            
            this.$watch('historicalControls.timeRange', (value) => {
                this.controls.timeRange = value;
            });
            
            this.$watch('historicalControls.dataType', (value) => {
                this.controls.dataType = value;
            });
            
            this.$watch('historicalControls.selectedModule', (value) => {
                this.controls.selectedModule = value;
            });
            try {
                this.isLoading = true;
                this.hasError = false;
                this.errorMessage = '';
                
                window.logger.logInit();
                
                // Wait for Plotly to be available
                let retries = 0;
                while (typeof Plotly === 'undefined' && retries < 10) {
                    window.logger.debug('Waiting for Plotly to load...', { retry: retries });
                    await new Promise(resolve => setTimeout(resolve, 500));
                    retries++;
                }
                
                if (typeof Plotly === 'undefined') {
                    window.logger.error('Plotly failed to load after retries');
                    this.chartsDisabled = true;
                } else {
                    window.logger.info('Plotly loaded successfully');
                }
                
                // Wait for DOM to be ready
                await new Promise(resolve => setTimeout(resolve, 100));
                
                
                
                // Set up charts first
                this.setupCharts();
                
                // Wait a bit for charts to be ready
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Then load data
                await this.loadInitialData();
                
                this.startAutoRefresh();
                this.isLoading = false;
                window.logger.info('Dashboard initialization completed');
            } catch (error) {
                window.logger.logError(error, 'Dashboard initialization failed');
                this.isLoading = false;
                this.hasError = true;
                this.errorMessage = 'Failed to initialize dashboard. Please refresh the page.';
            }
        },
        
        async loadInitialData() {
            await Promise.all([
                this.loadSystemStatus(),
                this.loadCurrentWeather(),
                this.loadModelMetrics(),
                this.loadModules()
            ]);
            
            // Load sensor data and predictions, then update charts
            await this.loadSensorData();
            await this.loadSensorData('historical'); // Also load historical data
            await this.loadPredictions();
            
            // Update charts after data is loaded
            if (this.sensorData.length > 0 && !this.chartsDisabled) {
                if (this.temperatureChart) {
                    try {
                        this.updateChart('Temperature');
                    } catch (error) {
                        console.error('Failed to update temperature chart:', error);
                    }
                }
                if (this.humidityChart) {
                    try {
                        this.updateChart('Humidity');
                    } catch (error) {
                        console.error('Failed to update humidity chart:', error);
                    }
                }
                if (this.pressureChart) {
                    try {
                        this.updateChart('Pressure');
                    } catch (error) {
                        console.error('Failed to update pressure chart:', error);
                    }
                }
            }
            
            this.updateLastUpdateTime();
        },
        
        async loadSystemStatus() {
            try {
                const response = await fetch('/api/stats');
                const data = await response.json();
                
                // Check if source database is working
                // Consider it healthy if status is 'online' OR if we have sensor records (indicating successful connection)
                const sourceDbHealthy = data.raw_data?.status === 'online' || 
                                       (data.raw_data?.sensor_records !== undefined && data.raw_data?.sensor_records >= 0);
                
                this.systemStatus = {
                    sourceDb: sourceDbHealthy,
                    scheduler: data.is_running === true,
                    model: data.model_trained === true,
                    records: data.preprocessed_records || 0
                };
            } catch (error) {
                window.logger.logError(error, 'Error loading system status');
                // If we can't even fetch stats, assume database is down
                this.systemStatus = {
                    sourceDb: false,
                    scheduler: false,
                    model: false,
                    records: 0
                };
            }
        },
        
        async loadCurrentWeather() {
            try {
                this.currentWeatherLoading = true;
                this.currentWeatherError = null;
                
                // Try preprocessed data first
                let response = await fetch('/api/preprocessed-data?hours_back=1&limit=1');
                let data = await response.json();
                
                if (data.length > 0) {
                    this.currentWeather = {
                        temperature: data[0].temperature,
                        humidity: data[0].humidity,
                        pressure: data[0].pressure,
                        module: 'preprocessed',
                        dataSource: 'preprocessed',
                        timestamp: new Date(data[0].timestamp).toLocaleString(undefined, {
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit',
                            timeZoneName: 'short'
                        }),
                        rawTimestamp: data[0].timestamp
                    };
                } else {
                    // Fallback to source data
                    response = await fetch('/api/sensor-data?hours=1&limit=1');
                    data = await response.json();
                    if (data.length > 0) {
                        this.currentWeather = {
                            temperature: data[0].temperature,
                            humidity: data[0].humidity,
                            pressure: data[0].pressure,
                            module: data[0].module,
                            dataSource: 'source',
                            timestamp: new Date(data[0].timestamp).toLocaleString(undefined, {
                                year: 'numeric',
                                month: '2-digit',
                                day: '2-digit',
                                hour: '2-digit',
                                minute: '2-digit',
                                second: '2-digit',
                                timeZoneName: 'short'
                            }),
                            rawTimestamp: data[0].timestamp
                        };
                    } else {
                        // No data available, but don't show as error - just leave empty
                        this.currentWeather = {};
                    }
                }
                
                // Calculate trends if we have historical data
                if (this.sensorData && this.sensorData.length > 1) {
                    this.calculateWeatherTrends();
                }
                
            } catch (error) {
                window.logger.logError(error, 'Error loading current weather');
                this.currentWeatherError = 'Failed to load weather data';
            } finally {
                this.currentWeatherLoading = false;
            }
        },
        
        async loadModelMetrics() {
            try {
                const response = await fetch('/api/model/benchmark');
                if (response.ok) {
                    const data = await response.json();
                    this.modelMetrics = {
                        mae: data.mae,
                        rmse: data.rmse,
                        r2: data.r2,
                        error: null
                    };
                } else {
                    const errorData = await response.json();
                    this.modelMetrics.error = errorData.error || 'No benchmark data available';
                }
            } catch (error) {
                this.modelMetrics.error = 'Error loading benchmark data';
            }
        },
        
        async loadPredictions() {
            try {
                // Use the time range for predictions as well, not just forecast hours
                const response = await fetch(`/api/predictions?hours=${this.controls.timeRange}`);
                if (!response.ok) {
                    console.warn('Failed to load predictions:', response.status);
                    this.recentPredictions = [];
                    return;
                }
                const data = await response.json();
                window.logger.logData(data.length, 'Predictions loaded');
                
                // Sort data by timestamp to ensure chronological order
                const sortedData = Array.isArray(data) ? data.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)) : [];
                
                if (sortedData.length > 0) {
                    window.logger.debug('Prediction time range:', new Date(sortedData[0].timestamp), 'to', new Date(sortedData[sortedData.length - 1].timestamp));
                }
                this.recentPredictions = sortedData;
                
                // Set last predicted temperature and time (use the most recent prediction)
                if (this.recentPredictions.length > 0) {
                    // Get the most recent prediction (last in the array since it's sorted by timestamp)
                    const latestPrediction = this.recentPredictions[this.recentPredictions.length - 1];
                    this.lastPredictedTemp = latestPrediction.predicted_temperature;
                    this.lastPredictedTempTime = latestPrediction.timestamp;
                } else {
                    this.lastPredictedTemp = null;
                    this.lastPredictedTempTime = null;
                }
                
                // Only update chart if we have data and chart is ready and not disabled
                if (this.recentPredictions.length > 0 && this.predictionsChart && !this.chartsDisabled) {
                    this.updatePredictionsChart();
                }
            } catch (error) {
                window.logger.logError(error, 'Error loading predictions');
                this.recentPredictions = [];
            }
        },
        
        async loadSensorData(controlSet = 'controls') {
            try {
                const controls = controlSet === 'historical' ? this.historicalControls : this.controls;
                window.logger.debug(`Loading sensor data with ${controlSet}:`, controls);
                
                const moduleParam = controls.selectedModule ? `&module_id=${controls.selectedModule}` : '';
                
                let response;
                let url;
                if (controls.dataType === 'preprocessed') {
                    // Use preprocessed data endpoint
                    url = `/api/preprocessed-data?hours_back=${controls.timeRange}${moduleParam}`;
                    response = await fetch(url);
                } else {
                    // Use source data endpoint
                    url = `/api/sensor-data?hours=${controls.timeRange}${moduleParam}`;
                    response = await fetch(url);
                }
                
                window.logger.debug('Fetching sensor data from:', url);
                
                if (!response.ok) {
                    console.warn('Failed to load sensor data:', response.status);
                    this.sensorData = [];
                    return;
                }
                const data = await response.json();
                window.logger.logData(data.length, 'Sensor data loaded');
                
                // Sort data by timestamp to ensure chronological order
                const sortedData = Array.isArray(data) ? data.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)) : [];
                
                if (sortedData.length > 0) {
                    const startTime = new Date(sortedData[0].timestamp);
                    const endTime = new Date(sortedData[sortedData.length - 1].timestamp);
                    window.logger.debug('Time range:', startTime, 'to', endTime);
                    
                    // Additional debugging for raw source data
                    if (controls.dataType === 'source') {
                        const timeSpan = (endTime - startTime) / (1000 * 60 * 60); // hours
                        const avgInterval = timeSpan / (sortedData.length - 1); // hours between points
                        window.logger.debug(`Raw source data: ${sortedData.length} points over ${timeSpan.toFixed(1)} hours (avg interval: ${avgInterval.toFixed(2)} hours)`);
                        
                        // Check for data gaps
                        const gaps = [];
                        for (let i = 1; i < sortedData.length; i++) {
                            const prevTime = new Date(sortedData[i-1].timestamp);
                            const currTime = new Date(sortedData[i].timestamp);
                            const gap = (currTime - prevTime) / (1000 * 60 * 60); // hours
                            if (gap > 2) { // Gap larger than 2 hours
                                gaps.push({
                                    from: prevTime,
                                    to: currTime,
                                    gap: gap
                                });
                            }
                        }
                        if (gaps.length > 0) {
                            window.logger.warn(`Found ${gaps.length} data gaps in raw source data:`, gaps);
                        }
                        
                        // Log module distribution if no specific module selected
                        if (!controls.selectedModule) {
                            const moduleCounts = {};
                            sortedData.forEach(item => {
                                const module = item.module || 'unknown';
                                moduleCounts[module] = (moduleCounts[module] || 0) + 1;
                            });
                            window.logger.debug('Module distribution:', moduleCounts);
                        }
                    }
                }
                this.sensorData = sortedData;
                
                // Update individual charts if they're ready and not disabled
                if (this.sensorData.length > 0 && !this.chartsDisabled) {
                    window.logger.debug('Updating individual charts with', this.sensorData.length, 'data points');
                    if (this.temperatureChart) {
                        try {
                            this.updateChart('Temperature');
                        } catch (error) {
                            console.error('Failed to update temperature chart:', error);
                        }
                    }
                    if (this.humidityChart) {
                        try {
                            this.updateChart('Humidity');
                        } catch (error) {
                            console.error('Failed to update humidity chart:', error);
                        }
                    }
                    if (this.pressureChart) {
                        try {
                            this.updateChart('Pressure');
                        } catch (error) {
                            console.error('Failed to update pressure chart:', error);
                        }
                    }
                }
                
                // Calculate weather trends for current conditions
                if (this.sensorData.length > 1 && this.currentWeather.temperature) {
                    this.calculateWeatherTrends();
                }
            } catch (error) {
                window.logger.logError(error, 'Error loading sensor data');
                this.sensorData = [];
            }
        },
        
        async loadModules() {
            try {
                const response = await fetch('/api/modules');
                const data = await response.json();
                this.availableModules = data.modules || [];
            } catch (error) {
                window.logger.logError(error, 'Error loading modules');
            }
        },
        
        setupCharts() {
            window.logger.info('Setting up charts...');
            
            // Check if charts are disabled
            if (this.chartsDisabled) {
                window.logger.info('Charts are disabled, skipping initialization');
                return;
            }
            
            // Check if Plotly is available
            if (typeof Plotly === 'undefined') {
                window.logger.error('Plotly is not loaded');
                this.chartsDisabled = true;
                return;
            }
            
            window.logger.info('Plotly is available, proceeding with chart setup');
            
            // Define config for all charts
            const config = {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                displaylogo: false
            };
            
            // Predictions Chart
            const predictionsCtx = document.getElementById('predictionsChart');
            if (!predictionsCtx) {
                console.error('Predictions chart canvas not found');
                this.chartsDisabled = true;
                return;
            }
            
            window.logger.debug('Predictions chart container found:', predictionsCtx);
            
            try {
                // Create initial empty chart with proper Plotly structure
                const predictionsData = [
                    {
                        x: [],
                        y: [],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Historical Temperature',
                        line: {
                            color: 'rgb(59, 130, 246)',
                            width: 2
                        },
                        marker: {
                            size: 4,
                            color: 'rgb(59, 130, 246)'
                        },
                        hovertemplate: '%{x}<br>Temperature: %{y:.1f}¬∞C<extra></extra>'
                    },
                    {
                        x: [],
                        y: [],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Predicted Temperature',
                        line: {
                            color: 'rgb(239, 68, 68)',
                            width: 2,
                            dash: 'dash'
                        },
                        marker: {
                            size: 4,
                            color: 'rgb(239, 68, 68)'
                        },
                        hovertemplate: '%{x}<br>Predicted: %{y:.1f}¬∞C<extra></extra>'
                    }
                ];
                
                const predictionsLayout = {
                    title: {
                        text: 'Temperature Predictions vs Historical Data',
                        font: { size: 16 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 12 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Temperature (¬∞C)',
                            font: { size: 12 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    legend: {
                        orientation: 'h',
                        y: 1.1,
                        x: 0.5,
                        xanchor: 'center',
                        bgcolor: 'rgba(255,255,255,0.8)'
                    },
                    height: 400,
                    margin: { t: 60, b: 60, l: 60, r: 40 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                window.logger.debug('Creating predictions chart with data:', predictionsData);
                window.logger.debug('Layout:', predictionsLayout);
                
                Plotly.newPlot(predictionsCtx, predictionsData, predictionsLayout, config);
                this.predictionsChart = predictionsCtx;
                window.logger.info('Predictions chart initialized successfully');
                

            } catch (error) {
                console.error('Error creating predictions chart:', error);
                this.predictionsChart = null;
                this.chartsDisabled = true;
                this.disablePredictionsChart();
            }
            
                        // Temperature Chart
            const temperatureCtx = document.getElementById('temperatureChart');
            if (!temperatureCtx) {
                console.error('Temperature chart canvas not found');
                return;
            }
            
            try {
                const temperatureData = [
                    {
                        x: [],
                        y: [],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Temperature',
                        line: {
                            color: 'rgb(239, 68, 68)',
                            width: 2
                        },
                        marker: {
                            size: 3,
                            color: 'rgb(239, 68, 68)'
                        },
                        hovertemplate: '%{x}<br>Temperature: %{y:.1f}¬∞C<extra></extra>'
                    }
                ];
                
                const temperatureLayout = {
                    title: {
                        text: 'Temperature Over Time',
                        font: { size: 14 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 10 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Temperature (¬∞C)',
                            font: { size: 10 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    height: 300,
                    margin: { t: 40, b: 40, l: 50, r: 20 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                Plotly.newPlot(temperatureCtx, temperatureData, temperatureLayout, config);
                this.temperatureChart = temperatureCtx;
            } catch (error) {
                console.error('Error creating temperature chart:', error);
                this.temperatureChart = null;
            }
            
                        // Humidity Chart
            const humidityCtx = document.getElementById('humidityChart');
            if (!humidityCtx) {
                console.error('Humidity chart canvas not found');
                return;
            }
            
            try {
                const humidityData = [
                    {
                        x: [],
                        y: [],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Humidity',
                        line: {
                            color: 'rgb(59, 130, 246)',
                            width: 2
                        },
                        marker: {
                            size: 3,
                            color: 'rgb(59, 130, 246)'
                        },
                        hovertemplate: '%{x}<br>Humidity: %{y:.1f}%<extra></extra>'
                    }
                ];
                
                const humidityLayout = {
                    title: {
                        text: 'Humidity Over Time',
                        font: { size: 14 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 10 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Humidity (%)',
                            font: { size: 10 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    height: 300,
                    margin: { t: 40, b: 40, l: 50, r: 20 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                Plotly.newPlot(humidityCtx, humidityData, humidityLayout, config);
                this.humidityChart = humidityCtx;
            } catch (error) {
                console.error('Error creating humidity chart:', error);
                this.humidityChart = null;
            }
            
                        // Pressure Chart
            const pressureCtx = document.getElementById('pressureChart');
            if (!pressureCtx) {
                console.error('Pressure chart canvas not found');
                return;
            }
            
            try {
                const pressureData = [
                    {
                        x: [],
                        y: [],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Pressure',
                        line: {
                            color: 'rgb(34, 197, 94)',
                            width: 2
                        },
                        marker: {
                            size: 3,
                            color: 'rgb(34, 197, 94)'
                        },
                        hovertemplate: '%{x}<br>Pressure: %{y:.1f}hPa<extra></extra>'
                    }
                ];
                
                const pressureLayout = {
                    title: {
                        text: 'Pressure Over Time',
                        font: { size: 14 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 10 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Pressure (hPa)',
                            font: { size: 10 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    height: 300,
                    margin: { t: 40, b: 40, l: 50, r: 20 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                Plotly.newPlot(pressureCtx, pressureData, pressureLayout, config);
                this.pressureChart = pressureCtx;
            } catch (error) {
                console.error('Error creating pressure chart:', error);
                this.pressureChart = null;
            }
        },
        
        updatePredictionsChart() {
            if (this.chartsDisabled || !this.predictionsChart) {
                console.warn('Predictions chart not available or disabled');
                return;
            }
            
            try {
                // Use all available data instead of limiting to 50 points
                const historicalData = this.sensorData && this.sensorData.length > 0 ? this.sensorData : [];
                const predictionData = this.recentPredictions && this.recentPredictions.length > 0 ? this.recentPredictions : [];
                
                // Create data arrays for Plotly with proper timestamp handling
                const historicalX = historicalData.map(d => new Date(d.timestamp));
                const historicalY = historicalData.map(d => Number(d.temperature) || 0);
                
                const predictionX = predictionData.map(d => new Date(d.timestamp));
                const predictionY = predictionData.map(d => Number(d.predicted_temperature) || 0);
                
                // If we have no data at all, don't update the chart
                if (historicalX.length === 0 && predictionX.length === 0) {
                    console.warn('No data available for predictions chart');
                    return;
                }
                
                // Additional debugging for raw source data
                if (this.controls.dataType === 'source' && historicalData.length > 0) {
                    const startTime = historicalX[0];
                    const endTime = historicalX[historicalX.length - 1];
                    const timeSpan = (endTime - startTime) / (1000 * 60 * 60); // hours
                    const avgInterval = timeSpan / (historicalX.length - 1); // hours between points
                    
                    window.logger.debug(`Predictions chart - Raw source data: ${historicalX.length} points over ${timeSpan.toFixed(1)} hours (avg interval: ${avgInterval.toFixed(2)} hours)`);
                    
                    // Check for data quality issues
                    if (avgInterval > 1) {
                        window.logger.warn(`Large intervals detected in raw source data: ${avgInterval.toFixed(2)} hours average`);
                    }
                    
                    // Log module information if available
                    if (historicalData[0].module) {
                        const moduleCounts = {};
                        historicalData.forEach(item => {
                            const module = item.module || 'unknown';
                            moduleCounts[module] = (moduleCounts[module] || 0) + 1;
                        });
                        window.logger.debug('Predictions chart - Module distribution:', moduleCounts);
                    }
                }
                
                // Always use replot for better timestamp handling and to ensure proper updates
                this.replotPredictionsChart(historicalX, historicalY, predictionX, predictionY);
                
            } catch (error) {
                console.error('Error updating predictions chart:', error);
                // Disable the chart if it keeps failing
                this.disablePredictionsChart();
            }
        },
        
        replotPredictionsChart(historicalX, historicalY, predictionX, predictionY) {
            try {
                const plotData = [
                    {
                        x: historicalX,
                        y: historicalY,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Historical Temperature',
                        line: {
                            color: 'rgb(59, 130, 246)',
                            width: 2
                        },
                        marker: {
                            size: 4,
                            color: 'rgb(59, 130, 246)'
                        },
                        hovertemplate: '%{x}<br>Temperature: %{y:.1f}¬∞C<extra></extra>'
                    },
                    {
                        x: predictionX,
                        y: predictionY,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Predicted Temperature',
                        line: {
                            color: 'rgb(239, 68, 68)',
                            width: 2,
                            dash: 'dash'
                        },
                        marker: {
                            size: 4,
                            color: 'rgb(239, 68, 68)'
                        },
                        hovertemplate: '%{x}<br>Predicted: %{y:.1f}¬∞C<extra></extra>'
                    }
                ];
                
                const layout = {
                    title: {
                        text: 'Temperature Predictions vs Historical Data',
                        font: { size: 16 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 12 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: 'Temperature (¬∞C)',
                            font: { size: 12 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    legend: {
                        orientation: 'h',
                        y: 1.1,
                        x: 0.5,
                        xanchor: 'center',
                        bgcolor: 'rgba(255,255,255,0.8)'
                    },
                    height: 400,
                    margin: { t: 60, b: 60, l: 60, r: 40 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                const config = {
                    responsive: true,
                    displayModeBar: true,
                    modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                    displaylogo: false
                };
                
                Plotly.newPlot(this.predictionsChart, plotData, layout, config);

            } catch (error) {
                console.error('Error replotting predictions chart:', error);
                this.disablePredictionsChart();
            }
        },
        
        updateChart(chartType) {
            const chart = this.historicalCharts.find(c => c.name.toLowerCase() === chartType.toLowerCase());
            if (!chart) {
                window.logger.warn(`Chart type ${chartType} not found`);
                return;
            }
            
            // Get the correct chart element reference
            const chartElement = this[chart.id];
            
            if (this.chartsDisabled || !chartElement) {
                window.logger.warn(`${chartType} chart not available or disabled`);
                return;
            }
            
            try {
                if (!this.sensorData || this.sensorData.length === 0) {
                    window.logger.warn(`No sensor data available for ${chartType} chart`);
                    return;
                }
                
                window.logger.logData(this.sensorData.length, `${chartType} chart data points`);
                
                // Create data arrays for Plotly with proper timestamp handling
                const x = this.sensorData.map(d => new Date(d.timestamp));
                const values = this.sensorData.map(d => Number(d[chart.field]) || 0);
                
                // Replot the chart
                this.replotChart(chart, x, values);
                
            } catch (error) {
                window.logger.logError(error, `${chartType} chart update failed`);
                this.disableChart(chart.id);
            }
        },
        
        replotChart(chart, x, values) {
            try {
                window.logger.debug(`Replotting ${chart.name} chart with ${x.length} data points`);
                
                const plotData = [
                    {
                        x: x,
                        y: values,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: chart.name,
                        line: {
                            color: chart.color,
                            width: 2
                        },
                        marker: {
                            size: 3,
                            color: chart.color
                        },
                        hovertemplate: `%{x}<br>${chart.name}: %{y:.1f}${chart.unit}<extra></extra>`
                    }
                ];
                
                const layout = {
                    title: {
                        text: `${chart.name} Over Time`,
                        font: { size: 14 }
                    },
                    xaxis: {
                        title: {
                            text: 'Time',
                            font: { size: 10 }
                        },
                        type: 'date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    yaxis: {
                        title: {
                            text: `${chart.name} (${chart.unit})`,
                            font: { size: 10 }
                        },
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        autorange: true
                    },
                    hovermode: 'x unified',
                    height: 300,
                    margin: { t: 40, b: 40, l: 50, r: 20 },
                    plot_bgcolor: 'rgba(255,255,255,0.9)',
                    paper_bgcolor: 'rgba(255,255,255,0.9)'
                };
                
                const config = {
                    responsive: true,
                    displayModeBar: true,
                    modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                    displaylogo: false
                };
                
                const chartElement = this[chart.id];
                Plotly.newPlot(chartElement, plotData, layout, config);
                window.logger.info(`${chart.name} chart replotted successfully`);
                
            } catch (error) {
                window.logger.logError(error, `${chart.name} chart replot failed`);
                this.disableChart(chart.id);
            }
        },
        
        disablePredictionsChart() {
            window.logger.warn('Disabling predictions chart due to errors');
            if (this.predictionsChart) {
                try {
                    Plotly.purge(this.predictionsChart);
                } catch (e) {
                    window.logger.logError(e, 'Error purging predictions chart');
                }
                this.predictionsChart = null;
            }
            // Hide the chart container
            const container = document.querySelector('.chart-container');
            if (container) {
                container.innerHTML = '<div class="text-center py-8 text-gray-500">Predictions chart temporarily disabled due to data issues</div>';
            }
        },
        
        disableChart(chartId) {
            const chart = this.historicalCharts.find(c => c.id === chartId);
            if (chart) {
                window.logger.warn(`Disabling ${chart.name} chart due to errors`);
                const chartElement = this[chartId];
                if (chartElement) {
                    try {
                        Plotly.purge(chartElement);
                    } catch (e) {
                        window.logger.logError(e, `Error purging ${chart.name} chart`);
                    }
                    this[chartId] = null;
                }
            }
        },
        
        async updateData() {
            await this.loadSensorData();
            await this.loadPredictions(); // Also load predictions for the time range
            await this.loadCurrentWeather();
            
            // Update individual charts if they're ready and not disabled
            if (this.sensorData.length > 0 && !this.chartsDisabled) {
                if (this.temperatureChart) {
                    try {
                        this.updateChart('Temperature');
                    } catch (error) {
                        console.error('Failed to update temperature chart:', error);
                    }
                }
                if (this.humidityChart) {
                    try {
                        this.updateChart('Humidity');
                    } catch (error) {
                        console.error('Failed to update humidity chart:', error);
                    }
                }
                if (this.pressureChart) {
                    try {
                        this.updateChart('Pressure');
                    } catch (error) {
                        console.error('Failed to update pressure chart:', error);
                    }
                }
            }
            
            // Update predictions chart if ready and not disabled
            if (this.predictionsChart && this.recentPredictions.length > 0 && !this.chartsDisabled) {
                try {
                    this.updatePredictionsChart();
                } catch (error) {
                    console.error('Failed to update predictions chart:', error);
                }
            }
        },
        

        

        async refreshAnalysis() {
            this.analysisLoading = {
                timeSeries: true,
                distributions: true,
                correlation: true,
                temporal: true
            };
            
            const timestamp = new Date().getTime();
            const plots = ['time-series-plot', 'distribution-plot', 'correlation-plot', 'temporal-plot'];
            
            for (const plotId of plots) {
                const img = document.getElementById(plotId);
                if (img) {
                    img.src = img.src.split('?')[0] + '?t=' + timestamp;
                    img.onload = () => {
                        this.analysisLoading[plotId.replace('-plot', '')] = false;
                    };
                    img.onerror = () => {
                        this.analysisLoading[plotId.replace('-plot', '')] = false;
                    };
                }
            }
        },
        
        async refreshBenchmark() {
            await this.loadModelMetrics();
        },
        
        async refreshAllData() {
            await this.loadInitialData();
        },
        
        toggleAutoRefresh() {
            this.autoRefreshEnabled = !this.autoRefreshEnabled;
            if (this.autoRefreshEnabled) {
                this.startAutoRefresh();
            } else {
                this.stopAutoRefresh();
            }
        },
        
        startAutoRefresh() {
            if (this.autoRefreshInterval) {
                clearInterval(this.autoRefreshInterval);
            }
            this.autoRefreshInterval = setInterval(() => {
                this.loadPredictions();
                this.updateLastUpdateTime();
            }, 60000); // 1 minute
        },
        
        stopAutoRefresh() {
            if (this.autoRefreshInterval) {
                clearInterval(this.autoRefreshInterval);
                this.autoRefreshInterval = null;
            }
        },
        
        updateLastUpdateTime() {
            this.lastUpdateTime = new Date().toLocaleTimeString();
        },
        
        formatDateTime(timestamp) {
            return new Date(timestamp).toLocaleString(undefined, {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                timeZoneName: 'short'
            });
        },
        
        getConfidenceClass(confidence) {
            if (confidence >= 0.7) return 'confidence-high';
            if (confidence >= 0.5) return 'confidence-medium';
            return 'confidence-low';
        },

        getStatusClass(status) {
            if (status) {
                return 'status-green';
            } else {
                return 'status-red';
            }
        },
        
        calculateWeatherTrends() {
            if (!this.sensorData || this.sensorData.length < 2) return;
            
            // Get last 3 data points for trend calculation
            const recentData = this.sensorData.slice(-3);
            
            // Calculate temperature trend
            if (recentData.length >= 2) {
                const tempDiff = recentData[recentData.length - 1].temperature - recentData[0].temperature;
                if (Math.abs(tempDiff) < 0.5) {
                    this.currentWeather.temperatureTrend = 'stable';
                } else {
                    this.currentWeather.temperatureTrend = tempDiff > 0 ? 'up' : 'down';
                }
            }
            
            // Calculate pressure trend
            if (recentData.length >= 2) {
                const pressureDiff = recentData[recentData.length - 1].pressure - recentData[0].pressure;
                if (Math.abs(pressureDiff) < 1) {
                    this.currentWeather.pressureTrend = 'stable';
                } else {
                    this.currentWeather.pressureTrend = pressureDiff > 0 ? 'up' : 'down';
                }
            }
        },
        
        getWeatherSummary() {
            if (!this.currentWeather.temperature) return 'Weather data unavailable';
            
            const temp = this.currentWeather.temperature;
            const humidity = this.currentWeather.humidity;
            
            if (temp >= 30) return 'Hot';
            if (temp >= 25) return 'Warm';
            if (temp >= 20) return 'Mild';
            if (temp >= 15) return 'Cool';
            if (temp >= 10) return 'Cold';
            return 'Very Cold';
        },
        
        getWeatherDescription() {
            if (!this.currentWeather.temperature) return '';
            
            const temp = this.currentWeather.temperature;
            const humidity = this.currentWeather.humidity;
            
            if (temp >= 30 && humidity >= 80) return 'Hot and Humid';
            if (temp >= 30) return 'Hot and Dry';
            if (temp >= 25 && humidity >= 80) return 'Warm and Humid';
            if (temp >= 25) return 'Warm and Pleasant';
            if (temp >= 20 && humidity >= 80) return 'Mild and Humid';
            if (temp >= 20) return 'Mild and Comfortable';
            if (temp >= 15) return 'Cool and Refreshing';
            if (temp >= 10) return 'Cold';
            return 'Very Cold';
        },
        
        getDataAge() {
            if (!this.currentWeather.rawTimestamp) return 'Unknown';
            
            const now = new Date();
            const dataTime = new Date(this.currentWeather.rawTimestamp);
            const diffMs = now - dataTime;
            const diffMinutes = Math.floor(diffMs / (1000 * 60));
            
            if (diffMinutes < 1) return 'Just now';
            if (diffMinutes < 60) return `${diffMinutes} min ago`;
            
            const diffHours = Math.floor(diffMinutes / 60);
            if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
            
            const diffDays = Math.floor(diffHours / 24);
            return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
        },
        

        
        getRawSourceDataQuality() {
            if (this.controls.dataType !== 'source' || this.sensorData.length === 0) {
                return null;
            }
            
            const data = this.sensorData;
            const timeSpan = (new Date(data[data.length - 1].timestamp) - new Date(data[0].timestamp)) / (1000 * 60 * 60); // hours
            const avgInterval = timeSpan / (data.length - 1); // hours between points
            
            // Calculate gaps
            const gaps = [];
            for (let i = 1; i < data.length; i++) {
                const prevTime = new Date(data[i-1].timestamp);
                const currTime = new Date(data[i].timestamp);
                const gap = (currTime - prevTime) / (1000 * 60 * 60); // hours
                if (gap > 2) {
                    gaps.push(gap);
                }
            }
            
            return {
                totalPoints: data.length,
                timeSpan: timeSpan,
                avgInterval: avgInterval,
                gaps: gaps.length,
                maxGap: gaps.length > 0 ? Math.max(...gaps) : 0,
                quality: avgInterval <= 0.5 ? 'good' : avgInterval <= 1 ? 'fair' : 'poor'
            };
        },
        
        getRawSourceDataQualityText() {
            const quality = this.getRawSourceDataQuality();
            if (!quality) return '';
            
            let text = `${quality.totalPoints} points over ${quality.timeSpan.toFixed(1)}h`;
            text += ` (avg: ${quality.avgInterval.toFixed(2)}h)`;
            
            if (quality.gaps > 0) {
                text += ` - ${quality.gaps} gaps (max: ${quality.maxGap.toFixed(1)}h)`;
            }
            
            return text;
        },
        
        getHistoricalDataQuality() {
            if (this.historicalControls.dataType !== 'source' || this.sensorData.length === 0) {
                return null;
            }
            
            const data = this.sensorData;
            const timeSpan = (new Date(data[data.length - 1].timestamp) - new Date(data[0].timestamp)) / (1000 * 60 * 60); // hours
            const avgInterval = timeSpan / (data.length - 1); // hours between points
            
            // Calculate gaps
            const gaps = [];
            for (let i = 1; i < data.length; i++) {
                const prevTime = new Date(data[i-1].timestamp);
                const currTime = new Date(data[i].timestamp);
                const gap = (currTime - prevTime) / (1000 * 60 * 60); // hours
                if (gap > 2) {
                    gaps.push(gap);
                }
            }
            
            return {
                totalPoints: data.length,
                timeSpan: timeSpan,
                avgInterval: avgInterval,
                gaps: gaps.length,
                maxGap: gaps.length > 0 ? Math.max(...gaps) : 0,
                quality: avgInterval <= 0.5 ? 'good' : avgInterval <= 1 ? 'fair' : 'poor'
            };
        },
        
        getHistoricalDataQualityText() {
            const quality = this.getHistoricalDataQuality();
            if (!quality) return '';
            
            let text = `${quality.totalPoints} points over ${quality.timeSpan.toFixed(1)}h`;
            text += ` (avg: ${quality.avgInterval.toFixed(2)}h)`;
            
            if (quality.gaps > 0) {
                text += ` - ${quality.gaps} gaps (max: ${quality.maxGap.toFixed(1)}h)`;
            }
            
            return text;
        }
    }
}
</script>
{% endblock %} 